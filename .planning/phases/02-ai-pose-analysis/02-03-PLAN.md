---
phase: 02-ai-pose-analysis
plan: 03
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/app/api/analysis/route.ts
autonomous: true
requirements: [AI-01, AI-02, AI-03]

must_haves:
  truths:
    - "POST /api/analysis accepts { videoId, frames[], framingWarning? } and returns 200"
    - "Each frame row is upserted (not inserted) using ON CONFLICT so re-analysis cleanly overwrites"
    - "video_analyses status is set to 'complete' after all frames are saved"
    - "Non-existent video_id returns 404; unauthorized coach returns 403"
  artifacts:
    - path: "src/app/api/analysis/route.ts"
      provides: "POST /api/analysis — persists analysis results to Supabase"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/analysis/route.ts"
      to: "video_analyses table (status update)"
      via: "service role Supabase client"
      pattern: "video_analyses.*update.*complete"
    - from: "src/app/api/analysis/route.ts"
      to: "video_analysis_frames table (upsert)"
      via: "upsert with onConflict: video_id,frame_index"
      pattern: "video_analysis_frames.*upsert"
---

<objective>
Create the POST /api/analysis route that persists MediaPipe results from the browser Web Worker to Supabase. This route is the bridge between client-side analysis and the database.

Purpose: The usePoseAnalysis hook (Plan 04) calls this route after analysis completes. Without this route there is no persistence — analysis runs but results are lost on page reload.
Output: src/app/api/analysis/route.ts
</objective>

<execution_context>
@/Users/abhishekhodavdekar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhishekhodavdekar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-ai-pose-analysis/02-RESEARCH.md
@.planning/phases/02-ai-pose-analysis/02-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

<interfaces>
<!-- From src/types/analysis.ts (Plan 01) -->
```typescript
export interface AnalysisPayload {
  videoId: string
  frames: FrameAnalysis[]
  framingWarning?: string
}

export interface FrameAnalysis {
  frameIndex: number
  timestampMs: number
  landmarks: NormalizedLandmark[]
  angles: FrameAngles
  flags: MechanicsFlag[]
}

export interface FrameRow {
  video_id: string
  frame_index: number
  timestamp_ms: number
  landmarks: NormalizedLandmark[]
  elbow_slot_deg: number | null
  shoulder_tilt_deg: number | null
  hip_rotation_deg: number | null
  flags: MechanicsFlag[]
}
```

<!-- Route handler pattern from Phase 1 -->
<!-- Service role client pattern: -->
```typescript
import { createClient } from '@supabase/supabase-js'
function getServiceClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}
```
<!-- Auth pattern from Phase 1: -->
```typescript
import { createServerClient } from '@supabase/ssr'
// Use cookies() from next/headers for authenticated user lookup
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: POST /api/analysis route — persist analysis results</name>
  <files>src/app/api/analysis/route.ts</files>
  <action>
Create `src/app/api/analysis/route.ts`:

```typescript
// src/app/api/analysis/route.ts
// POST /api/analysis — persists MediaPipe pose analysis results from browser worker to Supabase
// Called by usePoseAnalysis hook after analysis completes

import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import { createServerClient } from '@supabase/ssr'
import { createClient } from '@supabase/supabase-js'
import type { AnalysisPayload, FrameRow } from '@/types/analysis'

function getServiceClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}

async function getAuthUser() {
  const cookieStore = await cookies()
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
    {
      cookies: {
        getAll: () => cookieStore.getAll(),
        setAll: (toSet) => {
          try {
            toSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Route handler — cannot set cookies on response after streaming starts
          }
        },
      },
    }
  )
  const { data: { user }, error } = await supabase.auth.getUser()
  if (error || !user) return null
  return user
}

export async function POST(request: Request): Promise<NextResponse> {
  // 1. Verify authenticated user
  const user = await getAuthUser()
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // 2. Parse request body
  let payload: AnalysisPayload
  try {
    payload = await request.json()
  } catch {
    return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 })
  }

  const { videoId, frames, framingWarning } = payload
  if (!videoId || !Array.isArray(frames)) {
    return NextResponse.json({ error: 'Missing required fields: videoId, frames' }, { status: 400 })
  }

  const supabase = getServiceClient()

  // 3. Verify the video exists and belongs to this coach
  const { data: video, error: videoError } = await supabase
    .from('videos')
    .select('id, coach_id')
    .eq('id', videoId)
    .single()

  if (videoError || !video) {
    return NextResponse.json({ error: 'Video not found' }, { status: 404 })
  }

  if (video.coach_id !== user.id) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
  }

  // 4. Set status to 'analyzing' to prevent race conditions on re-analyze
  await supabase
    .from('video_analyses')
    .update({ status: 'analyzing', progress_pct: 0 })
    .eq('video_id', videoId)

  // 5. Upsert all frame rows — ON CONFLICT ensures re-analysis cleanly overwrites
  const frameRows: FrameRow[] = frames.map((f) => ({
    video_id: videoId,
    frame_index: f.frameIndex,
    timestamp_ms: f.timestampMs,
    landmarks: f.landmarks,
    elbow_slot_deg: f.angles.elbowSlotDeg,
    shoulder_tilt_deg: f.angles.shoulderTiltDeg,
    hip_rotation_deg: f.angles.hipRotationDeg,
    flags: f.flags,
  }))

  const { error: upsertError } = await supabase
    .from('video_analysis_frames')
    .upsert(frameRows, { onConflict: 'video_id,frame_index' })

  if (upsertError) {
    console.error('[api/analysis] Frame upsert failed:', upsertError.message)
    await supabase
      .from('video_analyses')
      .update({ status: 'error', error_message: upsertError.message })
      .eq('video_id', videoId)
    return NextResponse.json({ error: 'Failed to save frame data' }, { status: 500 })
  }

  // 6. Mark analysis complete
  const { error: completeError } = await supabase
    .from('video_analyses')
    .update({
      status: frames.length > 0 ? 'complete' : 'low_confidence',
      progress_pct: 100,
      frame_count: frames.length,
      analyzed_at: new Date().toISOString(),
      framing_warning: framingWarning ?? null,
    })
    .eq('video_id', videoId)

  if (completeError) {
    console.error('[api/analysis] Status update failed:', completeError.message)
    return NextResponse.json({ error: 'Analysis saved but status update failed' }, { status: 500 })
  }

  return NextResponse.json({
    success: true,
    videoId,
    frameCount: frames.length,
    status: frames.length > 0 ? 'complete' : 'low_confidence',
  })
}
```
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - src/app/api/analysis/route.ts exports POST handler
    - Route validates auth (401 for unauthenticated), video ownership (403 for non-owner), 404 for missing video
    - Uses upsert with onConflict: 'video_id,frame_index' — safe for re-analysis
    - Sets status to 'complete' after successful frame upsert
    - npx tsc --noEmit exits 0
  </done>
</task>

</tasks>

<verification>
- src/app/api/analysis/route.ts exists and exports POST
- Route uses service role client for upserts (bypasses RLS)
- Route uses user auth client to verify coach ownership
- `npx tsc --noEmit` exits 0
- No circular imports (route imports only from @/types/analysis)
</verification>

<success_criteria>
After Phase 2 Plan 03:
1. POST /api/analysis exists and handles: 401 (unauth), 403 (wrong coach), 404 (no video), 500 (DB error), 200 (success)
2. Frame data upserted safely — re-analysis overwrites prior results without duplicate rows
3. video_analyses.status transitions: analyzing → complete (or low_confidence if 0 frames)
4. TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-pose-analysis/02-03-SUMMARY.md`
</output>
