---
phase: 02-ai-pose-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/005_video_analyses.sql
  - src/types/analysis.ts
  - src/inngest/functions/transcode-video.ts
autonomous: true
requirements: [AI-01, AI-02, AI-03]

must_haves:
  truths:
    - "video_analyses table exists in Supabase with status/progress_pct columns"
    - "video_analysis_frames table exists with JSONB landmarks column and UNIQUE(video_id, frame_index)"
    - "After transcoding completes, a video_analyses row with status='pending' is inserted automatically"
    - "TypeScript types for FrameAnalysis, MechanicsFlag, and VideoAnalysis are exported from src/types/analysis.ts"
  artifacts:
    - path: "supabase/migrations/005_video_analyses.sql"
      provides: "video_analyses + video_analysis_frames schema + RLS"
      contains: "CREATE TABLE video_analyses"
    - path: "src/types/analysis.ts"
      provides: "FrameAnalysis, MechanicsFlag, VideoAnalysis TypeScript contracts"
      exports: ["FrameAnalysis", "MechanicsFlag", "VideoAnalysis", "AnalysisStatus"]
    - path: "src/inngest/functions/transcode-video.ts"
      provides: "Auto-inserts pending analysis row after transcoding"
      contains: "video_analyses"
  key_links:
    - from: "src/inngest/functions/transcode-video.ts"
      to: "supabase video_analyses table"
      via: "Step 6: signal-analysis-ready"
      pattern: "video_analyses.*insert"
    - from: "src/types/analysis.ts"
      to: "all Phase 2 components and hooks"
      via: "TypeScript imports"
      pattern: "export.*FrameAnalysis"
---

<objective>
Create the database schema for analysis results and TypeScript type contracts, then wire the Inngest transcoding pipeline to auto-create a pending analysis row after each successful transcode.

Purpose: This is the foundation everything else in Phase 2 builds on. Components need types. The browser worker needs a row to update. The API route needs the schema to exist.
Output: Migration SQL, TypeScript type file, updated transcode-video.ts with Step 6.
</objective>

<execution_context>
@/Users/abhishekhodavdekar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhishekhodavdekar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-ai-pose-analysis/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

<interfaces>
<!-- Existing Inngest patterns from Phase 1 -->
<!-- From src/inngest/functions/transcode-video.ts -->

```typescript
// getServiceClient() pattern — use for any Supabase writes in Inngest
function getServiceClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}

// Step pattern — Step 5 ends with:
await step.run('update-status', async () => {
  const supabase = getServiceClient()
  const { error } = await supabase
    .from('videos')
    .update({ status: 'ready', hls_url, thumbnail_url, transcoded_at })
    .eq('id', videoId)
  if (error) throw new Error(`DB update failed: ${error.message}`)
})

return { videoId, status: 'ready' }
```

<!-- Migration numbering: 001–004 exist; next is 005 -->
<!-- RLS pattern from 001_initial_schema.sql: -->
<!-- ALTER TABLE x ENABLE ROW LEVEL SECURITY -->
<!-- CREATE POLICY "name" ON x FOR SELECT USING (auth.uid() = coach_id) -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Supabase migration — video_analyses and video_analysis_frames tables</name>
  <files>supabase/migrations/005_video_analyses.sql</files>
  <action>
Create `supabase/migrations/005_video_analyses.sql` with the following exact schema (from RESEARCH.md Pattern 4):

```sql
-- video_analyses: one row per video, tracks analysis lifecycle
CREATE TABLE video_analyses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  video_id UUID NOT NULL REFERENCES videos(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'analyzing', 'complete', 'error', 'low_confidence')),
  progress_pct INTEGER DEFAULT 0,
  frame_count INTEGER,
  analyzed_at TIMESTAMPTZ,
  error_message TEXT,
  framing_warning TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(video_id)
);

-- video_analysis_frames: one row per sampled frame (5fps)
CREATE TABLE video_analysis_frames (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  video_id UUID NOT NULL REFERENCES videos(id) ON DELETE CASCADE,
  frame_index INTEGER NOT NULL,
  timestamp_ms INTEGER NOT NULL,
  landmarks JSONB NOT NULL,
  elbow_slot_deg REAL,
  shoulder_tilt_deg REAL,
  hip_rotation_deg REAL,
  flags JSONB,
  UNIQUE(video_id, frame_index)
);

CREATE INDEX idx_vaf_video_id ON video_analysis_frames(video_id);
CREATE INDEX idx_vaf_video_ts ON video_analysis_frames(video_id, timestamp_ms);

-- RLS: same visibility rules as videos table
-- coaches see their own videos' analysis; athletes see their own
ALTER TABLE video_analyses ENABLE ROW LEVEL SECURITY;
ALTER TABLE video_analysis_frames ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Coaches can read own video analyses"
  ON video_analyses FOR SELECT
  USING (
    video_id IN (
      SELECT id FROM videos WHERE coach_id = auth.uid()
    )
  );

CREATE POLICY "Athletes can read own video analyses"
  ON video_analyses FOR SELECT
  USING (
    video_id IN (
      SELECT id FROM videos WHERE athlete_id = auth.uid()
    )
  );

CREATE POLICY "Service role can insert analyses"
  ON video_analyses FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Service role can update analyses"
  ON video_analyses FOR UPDATE
  USING (true);

CREATE POLICY "Coaches can read own frame data"
  ON video_analysis_frames FOR SELECT
  USING (
    video_id IN (
      SELECT id FROM videos WHERE coach_id = auth.uid()
    )
  );

CREATE POLICY "Athletes can read own frame data"
  ON video_analysis_frames FOR SELECT
  USING (
    video_id IN (
      SELECT id FROM videos WHERE athlete_id = auth.uid()
    )
  );

CREATE POLICY "Service role can insert frame data"
  ON video_analysis_frames FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Service role can upsert frame data"
  ON video_analysis_frames FOR UPDATE
  USING (true);
```

Note: Service role bypasses RLS entirely (SUPABASE_SERVICE_ROLE_KEY). The service role policies above are belt-and-suspenders for anon key edge cases, but the real enforcement is the coach/athlete SELECT policies.

Run: `npx supabase db push` or apply via Supabase Dashboard SQL editor.
  </action>
  <verify>
    <automated>npx supabase db push --dry-run 2>&1 | grep -E "(error|Error|Success|up to date)" || echo "Check migration file syntax manually if supabase CLI not configured"</automated>
  </verify>
  <done>Migration file exists at supabase/migrations/005_video_analyses.sql. Both tables defined with UNIQUE constraints, indexes on video_id and (video_id, timestamp_ms), RLS enabled on both tables.</done>
</task>

<task type="auto">
  <name>Task 2: TypeScript type contracts + Inngest Step 6 wiring</name>
  <files>
    src/types/analysis.ts
    src/inngest/functions/transcode-video.ts
  </files>
  <action>
**Part A: Create src/types/analysis.ts**

```typescript
// src/types/analysis.ts
// Type contracts for Phase 2 AI pose analysis
// All downstream components, hooks, and API routes import from here

export type AnalysisStatus = 'pending' | 'analyzing' | 'complete' | 'error' | 'low_confidence'

export interface NormalizedLandmark {
  x: number
  y: number
  z: number
  visibility: number
}

export interface MechanicsFlag {
  issue: string
  confidence: number     // 0–1, derived from landmark visibility
  severity: 'warning' | 'error'
  jointIndices: number[]
}

export interface FrameAngles {
  elbowSlotDeg: number | null      // null when landmark visibility < 0.65
  shoulderTiltDeg: number | null
  hipRotationDeg: number | null
}

export interface FrameAnalysis {
  frameIndex: number
  timestampMs: number
  landmarks: NormalizedLandmark[]  // 33 MediaPipe body landmarks
  angles: FrameAngles
  flags: MechanicsFlag[]
}

export interface VideoAnalysis {
  id: string
  videoId: string
  status: AnalysisStatus
  progressPct: number
  frameCount: number | null
  analyzedAt: string | null
  errorMessage: string | null
  framingWarning: string | null
  createdAt: string
}

// Shape returned by POST /api/analysis request body
export interface AnalysisPayload {
  videoId: string
  frames: FrameAnalysis[]
  framingWarning?: string
}

// Shape for upsert into video_analysis_frames
export interface FrameRow {
  video_id: string
  frame_index: number
  timestamp_ms: number
  landmarks: NormalizedLandmark[]
  elbow_slot_deg: number | null
  shoulder_tilt_deg: number | null
  hip_rotation_deg: number | null
  flags: MechanicsFlag[]
}
```

**Part B: Add Step 6 to src/inngest/functions/transcode-video.ts**

After the existing Step 5 `update-status` step.run() block (which ends with `if (error) throw...`), and BEFORE the final `return { videoId, status: 'ready' }` line, add:

```typescript
    // Step 6: Create pending analysis record — triggers browser-side MediaPipe analysis on first review
    await step.run('signal-analysis-ready', async () => {
      const supabase = getServiceClient()
      const { error } = await supabase
        .from('video_analyses')
        .insert({
          video_id: videoId,
          status: 'pending',
          progress_pct: 0,
        })
      // Non-fatal: log but don't throw — transcoding already succeeded
      if (error) {
        console.error(`[transcode-video] Failed to create analysis row: ${error.message}`)
      }
    })
```

Do NOT change any existing steps. Do NOT modify the return statement. Insert the new step.run() block between Step 5 and the return.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - src/types/analysis.ts exists and exports: AnalysisStatus, NormalizedLandmark, MechanicsFlag, FrameAngles, FrameAnalysis, VideoAnalysis, AnalysisPayload, FrameRow
    - transcode-video.ts now has 6 step.run() calls; Step 6 inserts into video_analyses with status='pending'
    - npx tsc --noEmit exits 0
  </done>
</task>

</tasks>

<verification>
- Migration file 005_video_analyses.sql exists in supabase/migrations/
- Both tables have UNIQUE constraint preventing duplicate analysis rows per video
- RLS enabled on both new tables
- src/types/analysis.ts exports all 8 types
- transcode-video.ts Step 6 present (grep: `signal-analysis-ready`)
- `npx tsc --noEmit` exits 0
</verification>

<success_criteria>
After Phase 2 Plan 01:
1. `supabase/migrations/005_video_analyses.sql` defines video_analyses + video_analysis_frames with correct schema, indexes, and RLS
2. `src/types/analysis.ts` defines all TypeScript contracts needed by Plans 02–05
3. transcodeVideo Inngest function has Step 6 that auto-inserts `{status: 'pending'}` into video_analyses after each successful transcode
4. TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-pose-analysis/02-01-SUMMARY.md`
</output>
