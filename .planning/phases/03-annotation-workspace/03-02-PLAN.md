---
phase: 03-annotation-workspace
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/hooks/useAnnotations.ts
  - src/app/api/annotations/route.ts
autonomous: true
requirements: [VID-03, VID-04, ANN-05]

must_haves:
  truths:
    - "useAnnotations hook loads all annotation frames for a video on mount and exposes annotationsMap and saveFrame"
    - "saveFrame upserts one frame's shapes to Supabase and updates local annotationsMap optimistically"
    - "GET /api/annotations?videoId=X returns all annotation rows for that video as JSON"
    - "PUT /api/annotations upserts one frame's shapes using onConflict: video_id,frame_timestamp_ms"
    - "npx tsc --noEmit exits 0"
  artifacts:
    - path: "src/hooks/useAnnotations.ts"
      provides: "annotationsMap: Map<number, AnnotationShape[]> + saveFrame(timestampMs, shapes)"
      exports: ["useAnnotations"]
    - path: "src/app/api/annotations/route.ts"
      provides: "GET + PUT /api/annotations endpoints"
      contains: "video_annotations"
  key_links:
    - from: "src/hooks/useAnnotations.ts"
      to: "supabase video_annotations table"
      via: "Supabase browser client select + upsert"
      pattern: "video_annotations"
    - from: "src/hooks/useAnnotations.ts"
      to: "src/types/annotation.ts"
      via: "AnnotationShape import"
      pattern: "AnnotationShape"
---

<objective>
Build the data layer for annotations: the useAnnotations hook that loads and saves annotation data from Supabase, and the API route that the hook talks to.

Purpose: Plans 03 and 04 need a working data hook before they can wire the canvas to persistent storage. This plan delivers that hook and its backing API route.
Output: useAnnotations hook + /api/annotations GET + PUT route.
</objective>

<execution_context>
@/Users/abhishekhodavdekar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhishekhodavdekar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-annotation-workspace/03-RESEARCH.md
@.planning/phases/03-annotation-workspace/03-01-SUMMARY.md

<interfaces>
<!-- From src/types/annotation.ts (Plan 01) -->
```typescript
export type AnnotationShape = FreehandShape | LineShape | ArrowShape | AngleShape | TextShape
export interface AnnotationFrame { videoId: string; frameTimestampMs: number; shapes: AnnotationShape[] }
```

<!-- From src/lib/annotation/geometry.ts (Plan 01) -->
```typescript
export function findNearestAnnotatedFrame(annotationsMap: Map<number, unknown>, timMs: number, toleranceMs: number): number | null
```

<!-- Supabase browser client pattern (from existing hooks like usePoseAnalysis.ts) -->
```typescript
import { createBrowserClient } from '@supabase/ssr'
const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!
)
```

<!-- Supabase server client pattern for API routes (from existing routes) -->
<!-- Use createServerClient from @supabase/ssr with cookies() from next/headers -->
<!-- See src/app/api/analysis/route.ts for the established API route pattern -->

<!-- video_annotations table schema (Plan 01 migration 006): -->
<!-- columns: id, video_id, frame_timestamp_ms, shapes (JSONB), created_at, updated_at -->
<!-- UNIQUE(video_id, frame_timestamp_ms) -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: useAnnotations hook</name>
  <files>src/hooks/useAnnotations.ts</files>
  <action>
Create `src/hooks/useAnnotations.ts`.

Design decisions from RESEARCH.md:
- Load all frames for the video on mount (not lazy) — same pattern as usePoseAnalysis loading stored frames
- Expose `annotationsMap: Map<number, AnnotationShape[]>` keyed by frameTimestampMs for O(1) lookup during playback
- `saveFrame` upserts via the /api/annotations PUT endpoint, then updates local map optimistically
- Auto-save after each completed shape (debounced 500ms) in addition to save-on-exit — safest for iPad users who switch apps
- `annotatedTimestamps` derived value exposes all frame timestamps that have shapes, for timeline markers

```typescript
// src/hooks/useAnnotations.ts
'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { createBrowserClient } from '@supabase/ssr'
import type { AnnotationShape } from '@/types/annotation'

interface UseAnnotationsResult {
  // Map<frameTimestampMs, AnnotationShape[]> — all frames loaded on mount
  annotationsMap: Map<number, AnnotationShape[]>
  // Sorted array of frame timestamps that have at least one shape — for timeline markers
  annotatedTimestamps: number[]
  // Upsert shapes for one frame; updates local map and persists to Supabase
  saveFrame: (frameTimestampMs: number, shapes: AnnotationShape[]) => Promise<void>
  // True while any save is in flight
  isSaving: boolean
}

export function useAnnotations(videoId: string): UseAnnotationsResult {
  const [annotationsMap, setAnnotationsMap] = useState<Map<number, AnnotationShape[]>>(new Map())
  const [isSaving, setIsSaving] = useState(false)

  const supabase = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!
  )

  // Load all annotation frames on mount
  useEffect(() => {
    if (!videoId) return

    supabase
      .from('video_annotations')
      .select('frame_timestamp_ms, shapes')
      .eq('video_id', videoId)
      .then(({ data, error }) => {
        if (error || !data) return
        const map = new Map<number, AnnotationShape[]>()
        data.forEach((row) => {
          map.set(row.frame_timestamp_ms as number, row.shapes as AnnotationShape[])
        })
        setAnnotationsMap(map)
      })
  }, [videoId]) // eslint-disable-line react-hooks/exhaustive-deps

  // saveFrame: upsert one frame's shapes via API route, then update local map optimistically
  const saveFrame = useCallback(
    async (frameTimestampMs: number, shapes: AnnotationShape[]) => {
      // Optimistic local update immediately
      setAnnotationsMap((prev) => {
        const next = new Map(prev)
        if (shapes.length === 0) {
          next.delete(frameTimestampMs)
        } else {
          next.set(frameTimestampMs, shapes)
        }
        return next
      })

      setIsSaving(true)
      try {
        await fetch('/api/annotations', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoId, frameTimestampMs, shapes }),
        })
      } catch (err) {
        console.error('[useAnnotations] saveFrame failed:', err)
        // On failure: keep optimistic state; next page load will re-fetch from DB.
        // A toast notification is shown by the caller (AnnotationCanvas) if needed.
      } finally {
        setIsSaving(false)
      }
    },
    [videoId]
  )

  // Derive sorted list of timestamps with shapes for timeline markers
  const annotatedTimestamps = Array.from(annotationsMap.entries())
    .filter(([, shapes]) => shapes.length > 0)
    .map(([ts]) => ts)
    .sort((a, b) => a - b)

  return { annotationsMap, annotatedTimestamps, saveFrame, isSaving }
}
```
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - src/hooks/useAnnotations.ts exports useAnnotations(videoId: string): UseAnnotationsResult
    - Loads all video_annotations rows for the video on mount
    - Returns annotationsMap: Map<number, AnnotationShape[]>, annotatedTimestamps: number[], saveFrame, isSaving
    - saveFrame updates local map optimistically then calls PUT /api/annotations
    - npx tsc --noEmit exits 0
  </done>
</task>

<task type="auto">
  <name>Task 2: /api/annotations GET + PUT route</name>
  <files>src/app/api/annotations/route.ts</files>
  <action>
Create `src/app/api/annotations/route.ts`.

Design decisions from RESEARCH.md Pattern 10:
- GET ?videoId=X returns all rows for that video as `{ annotations: [{ frameTimestampMs, shapes }] }`
- PUT body `{ videoId, frameTimestampMs, shapes }` upserts using `onConflict: 'video_id,frame_timestamp_ms'`
- Auth check: require logged-in user (same guard as other /api routes)
- Use the server-side Supabase client from @supabase/ssr + next/headers cookies (not service role — coaches write via RLS)

Read `src/app/api/analysis/route.ts` to understand the established server-side Supabase client pattern and copy it exactly (createServerClient from @supabase/ssr with cookies from next/headers).

```typescript
// src/app/api/annotations/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

async function getSupabase() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
    {
      cookies: {
        getAll: () => cookieStore.getAll(),
        setAll: (cookiesToSet) => {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Ignored in Route Handlers — cookies set by middleware
          }
        },
      },
    }
  )
}

// GET /api/annotations?videoId=X
// Returns all annotation frames for a video
export async function GET(request: NextRequest) {
  const videoId = request.nextUrl.searchParams.get('videoId')
  if (!videoId) {
    return NextResponse.json({ error: 'videoId required' }, { status: 400 })
  }

  const supabase = await getSupabase()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { data, error } = await supabase
    .from('video_annotations')
    .select('frame_timestamp_ms, shapes')
    .eq('video_id', videoId)
    .order('frame_timestamp_ms', { ascending: true })

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({
    annotations: (data ?? []).map((row) => ({
      frameTimestampMs: row.frame_timestamp_ms,
      shapes: row.shapes,
    })),
  })
}

// PUT /api/annotations
// Upserts one frame's shapes. Body: { videoId, frameTimestampMs, shapes }
export async function PUT(request: NextRequest) {
  const supabase = await getSupabase()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  let body: { videoId: string; frameTimestampMs: number; shapes: unknown[] }
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 })
  }

  const { videoId, frameTimestampMs, shapes } = body
  if (!videoId || frameTimestampMs == null || !Array.isArray(shapes)) {
    return NextResponse.json({ error: 'videoId, frameTimestampMs, and shapes are required' }, { status: 400 })
  }

  const { error } = await supabase
    .from('video_annotations')
    .upsert(
      {
        video_id: videoId,
        frame_timestamp_ms: frameTimestampMs,
        shapes,
        updated_at: new Date().toISOString(),
      },
      { onConflict: 'video_id,frame_timestamp_ms' }
    )

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({ ok: true })
}
```

**Important:** Before writing this file, read `src/app/api/analysis/route.ts` to verify the exact createServerClient cookie pattern used in this project. Use the same pattern — do not deviate.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20 && npm run build 2>&1 | tail -20</automated>
  </verify>
  <done>
    - src/app/api/annotations/route.ts exports GET and PUT handlers
    - GET requires auth, returns all annotation frames for videoId as JSON array
    - PUT requires auth, upserts with onConflict: 'video_id,frame_timestamp_ms', sets updated_at
    - npm run build exits 0
  </done>
</task>

</tasks>

<verification>
- src/hooks/useAnnotations.ts exports useAnnotations(videoId: string)
- useAnnotations returns { annotationsMap, annotatedTimestamps, saveFrame, isSaving }
- annotationsMap is Map<number, AnnotationShape[]> loaded from video_annotations on mount
- annotatedTimestamps is number[] sorted ascending, only includes timestamps with shapes.length > 0
- saveFrame does optimistic local update before awaiting the API call
- src/app/api/annotations/route.ts exports GET and PUT
- GET returns { annotations: [{ frameTimestampMs, shapes }] }
- PUT upserts using onConflict: 'video_id,frame_timestamp_ms'
- Both handlers return 401 when user is not authenticated
- npm run build exits 0
</verification>

<success_criteria>
After Phase 3 Plan 02:
1. useAnnotations hook loads all annotation frames for a video on mount
2. saveFrame upserts via PUT /api/annotations and updates local map optimistically
3. GET /api/annotations?videoId=X returns all annotation rows as JSON
4. PUT /api/annotations upserts using conflict resolution on (video_id, frame_timestamp_ms)
5. Both API endpoints require authentication
6. npm run build exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/03-annotation-workspace/03-02-SUMMARY.md`
</output>
