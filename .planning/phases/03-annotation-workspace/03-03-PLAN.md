---
phase: 03-annotation-workspace
plan: 03
type: execute
wave: 3
depends_on: [03-01, 03-02]
files_modified:
  - src/components/review/AnnotationCanvas.tsx
  - src/components/review/AnnotationToolbar.tsx
autonomous: true
requirements: [ANN-01, ANN-02, ANN-03, ANN-04]

must_haves:
  truths:
    - "AnnotationCanvas renders a react-konva Stage absolutely stacked above the skeleton canvas"
    - "Freehand, line, arrow, angle measurement (three-point click), and text tools all work"
    - "Cmd+Z / Ctrl+Z undoes; Cmd+Shift+Z / Ctrl+Shift+Z redoes (history capped at 50)"
    - "Two-finger pinch zoom and two-finger pan work on iPad in annotation mode"
    - "AnnotationToolbar shows freehand, line, arrow, angle, text, color picker, and clear frame buttons"
    - "Color choices include red, green, yellow, white (minimum ANN-04)"
    - "AnnotationCanvas is dynamically imported with ssr: false (Konva accesses window/document)"
    - "npx tsc --noEmit exits 0"
  artifacts:
    - path: "src/components/review/AnnotationCanvas.tsx"
      provides: "react-konva Stage with all drawing tools, undo/redo, touch pan/zoom, read-only playback mode"
      exports: ["AnnotationCanvas"]
    - path: "src/components/review/AnnotationToolbar.tsx"
      provides: "Floating toolbar with tool selection and color picker"
      exports: ["AnnotationToolbar"]
  key_links:
    - from: "src/components/review/AnnotationCanvas.tsx"
      to: "src/types/annotation.ts"
      via: "AnnotationShape, AnnotationToolType imports"
      pattern: "AnnotationShape"
    - from: "src/components/review/AnnotationCanvas.tsx"
      to: "src/lib/annotation/geometry.ts"
      via: "computeAngleDeg import"
      pattern: "computeAngleDeg"
---

<objective>
Build the interactive annotation canvas (react-konva Stage) and its companion floating toolbar. This is the core of the Phase 3 feature: all drawing tools, undo/redo, touch support, and playback-mode rendering.

Purpose: Plan 04 wires these components into ReviewPageClient. They must be independently complete and testable first.
Output: AnnotationCanvas.tsx + AnnotationToolbar.tsx.
</objective>

<execution_context>
@/Users/abhishekhodavdekar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhishekhodavdekar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-annotation-workspace/03-CONTEXT.md
@.planning/phases/03-annotation-workspace/03-RESEARCH.md
@.planning/phases/03-annotation-workspace/03-02-SUMMARY.md

<interfaces>
<!-- From src/types/annotation.ts (Plan 01) -->
```typescript
export type AnnotationToolType = 'freehand' | 'line' | 'arrow' | 'angle' | 'text'
export type AnnotationColor = 'red' | 'green' | 'yellow' | 'white' | 'blue' | 'orange'
export type AnnotationShape = FreehandShape | LineShape | ArrowShape | AngleShape | TextShape
// All shapes use normalized 0–1 coordinates; multiply by stage width/height on render.
```

<!-- From src/lib/annotation/geometry.ts (Plan 01) -->
```typescript
export function computeAngleDeg(vertex: [number, number], arm1: [number, number], arm2: [number, number]): number
```

<!-- react-konva installation (must be done in this plan if not already installed) -->
<!-- npm install konva react-konva -->
<!-- react-konva@19.x required for React 19 (project uses react@19.2.3) -->
<!-- Verify: npm ls react-konva 2>&1 | head -5 — if missing, install first -->

<!-- RESEARCH.md Pattern 6: Free drawing with pointer events -->
<!-- RESEARCH.md Pattern 7: Angle measurement three-point click state machine -->
<!-- RESEARCH.md Pattern 8: Undo/redo with ref-based history, capped at 50 -->
<!-- RESEARCH.md Pattern 9: Two-finger pan/zoom with Konva.hitOnDragEnabled = true -->

<!-- CONTEXT.md locked decisions (NON-NEGOTIABLE): -->
<!-- - Floating toolbar appears ONLY in annotation mode — hidden during playback -->
<!-- - Toolbar: freehand, line, arrow, angle, text, color picker, clear frame -->
<!-- - Undo: Cmd+Z / Ctrl+Z; Redo: Cmd+Shift+Z / Ctrl+Shift+Z -->
<!-- - Color choices: red, green, yellow, white (minimum) -->
<!-- - In annotation mode: one finger draws; two-finger pinch zooms; two-finger drag pans -->
<!-- - Annotation canvas pointer-events: auto in annotation mode; none during playback (so native video controls work) -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-konva and build AnnotationCanvas</name>
  <files>src/components/review/AnnotationCanvas.tsx</files>
  <action>
**Step 0: Install react-konva if not already installed**

Run: `npm install konva react-konva`

This installs:
- `konva` — canvas 2D engine
- `react-konva@19.x` — React 19 bindings (npm resolves to v19 automatically with React 19)

Verify installation: `npm ls react-konva 2>&1 | head -3`

**Step 1: Create src/components/review/AnnotationCanvas.tsx**

This is a `'use client'` component. It must NOT be rendered in any server component directly — Plan 04 will wrap it with `dynamic(() => import('./AnnotationCanvas'), { ssr: false })` before use.

Key design decisions to implement (all from CONTEXT.md and RESEARCH.md):
- Konva Stage sized to video's rendered `clientWidth` × `clientHeight` via ResizeObserver
- `pointer-events: none` when `isAnnotationMode === false` (so native video controls work during playback)
- `pointer-events: auto` when `isAnnotationMode === true`
- `Konva.hitOnDragEnabled = true` set once at module init (enables touchmove on drag for two-finger zoom)
- All shape coordinates stored normalized (0–1); multiplied by `stageWidth` / `stageHeight` when rendering
- Undo/redo: ref-based history array, capped at 50 entries; Cmd+Z / Ctrl+Z (undo), Cmd+Shift+Z / Ctrl+Shift+Z (redo)
- In annotation mode, `onPointerDown` on the Stage freezes the current shapes into history before starting a new stroke
- In read-only (playback) mode, `shapes` prop is rendered directly with no pointer event handlers
- When `activeTool === 'angle'`, three sequential clicks set vertex → arm1 → arm2, then finalize the AngleShape
- When `activeTool === 'text'`, click places a text input overlay; on blur or Enter the TextShape is committed
- ResizeObserver watches the container div and updates `stageWidth` / `stageHeight` state

```typescript
// src/components/review/AnnotationCanvas.tsx
'use client'

import { useEffect, useRef, useState, useCallback } from 'react'
import { Stage, Layer, Line, Arrow, Text, Arc } from 'react-konva'
import type Konva from 'konva'
import type { KonvaEventObject } from 'konva/lib/Node'
import type { AnnotationShape, AnnotationToolType, AnnotationColor, FreehandShape, LineShape, ArrowShape, AngleShape, TextShape } from '@/types/annotation'
import { computeAngleDeg } from '@/lib/annotation/geometry'

// Enable touchmove during drag for two-finger pinch/pan on iPad
// Must be set before any Stage is created
import KonvaLib from 'konva'
KonvaLib.hitOnDragEnabled = true

const DEFAULT_STROKE_WIDTH = 3
const MAX_HISTORY = 50

interface AnnotationCanvasProps {
  // Container element to size the Stage against (video wrapper div)
  containerRef: React.RefObject<HTMLDivElement | null>
  // Whether the canvas is in active drawing mode (true) or read-only playback mode (false)
  isAnnotationMode: boolean
  // Shapes for the current frame — controlled externally
  shapes: AnnotationShape[]
  // Called whenever shapes for the current frame change (draw, undo, clear)
  onShapesChange: (shapes: AnnotationShape[]) => void
  // Active tool and color from AnnotationToolbar
  activeTool: AnnotationToolType
  activeColor: AnnotationColor
}

export function AnnotationCanvas({
  containerRef,
  isAnnotationMode,
  shapes,
  onShapesChange,
  activeTool,
  activeColor,
}: AnnotationCanvasProps) {
  const [stageWidth, setStageWidth] = useState(0)
  const [stageHeight, setStageHeight] = useState(0)

  // In-progress drawing state (refs to avoid re-renders during active stroke)
  const isDrawingRef = useRef(false)
  const inProgressShapeRef = useRef<AnnotationShape | null>(null)
  // For angle tool: tracks click count within current shape (0, 1, 2)
  const angleClickCountRef = useRef(0)
  const anglePointsRef = useRef<Array<[number, number]>>([])

  // Undo/redo history: array of shapes-arrays snapshots
  const historyRef = useRef<AnnotationShape[][]>([[]])
  const historyStepRef = useRef(0)

  // Text input overlay state
  const [textInput, setTextInput] = useState<{ x: number; y: number; normX: number; normY: number } | null>(null)
  const textInputRef = useRef<HTMLInputElement>(null)

  // Two-finger zoom/pan state
  const lastDist = useRef<number | null>(null)
  const stageRef = useRef<Konva.Stage | null>(null)

  // Size Stage to container using ResizeObserver
  useEffect(() => {
    const container = containerRef.current
    if (!container) return
    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect
        setStageWidth(width)
        setStageHeight(height)
      }
    })
    observer.observe(container)
    // Set initial size
    setStageWidth(container.clientWidth)
    setStageHeight(container.clientHeight)
    return () => observer.disconnect()
  }, [containerRef])

  // Keyboard undo/redo
  useEffect(() => {
    if (!isAnnotationMode) return
    const handleKeyDown = (e: KeyboardEvent) => {
      const isMod = e.metaKey || e.ctrlKey
      if (isMod && e.shiftKey && e.key === 'z') {
        e.preventDefault()
        redo()
      } else if (isMod && e.key === 'z') {
        e.preventDefault()
        undo()
      }
    }
    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [isAnnotationMode]) // eslint-disable-line react-hooks/exhaustive-deps

  // Sync history when shapes prop changes externally (e.g. on frame change from parent)
  // Reset history for the new frame
  const prevShapesRef = useRef<AnnotationShape[]>(shapes)
  useEffect(() => {
    // Only reset history if shapes changed externally (not from our own onShapesChange)
    if (prevShapesRef.current !== shapes) {
      historyRef.current = [shapes]
      historyStepRef.current = 0
      prevShapesRef.current = shapes
    }
  }, [shapes])

  function pushHistory(newShapes: AnnotationShape[]) {
    // Truncate future states on new action
    historyRef.current = historyRef.current.slice(0, historyStepRef.current + 1)
    historyRef.current.push(newShapes)
    // Cap at MAX_HISTORY
    if (historyRef.current.length > MAX_HISTORY) {
      historyRef.current.shift()
    } else {
      historyStepRef.current = historyRef.current.length - 1
    }
    prevShapesRef.current = newShapes
    onShapesChange(newShapes)
  }

  function undo() {
    if (historyStepRef.current === 0) return
    historyStepRef.current -= 1
    const prev = historyRef.current[historyStepRef.current]
    prevShapesRef.current = prev
    onShapesChange(prev)
  }

  function redo() {
    if (historyStepRef.current >= historyRef.current.length - 1) return
    historyStepRef.current += 1
    const next = historyRef.current[historyStepRef.current]
    prevShapesRef.current = next
    onShapesChange(next)
  }

  // Normalize a pixel position to 0–1
  function norm(px: number, py: number): [number, number] {
    return [stageWidth > 0 ? px / stageWidth : 0, stageHeight > 0 ? py / stageHeight : 0]
  }

  // Denormalize to pixel position
  function denorm(nx: number, ny: number): [number, number] {
    return [nx * stageWidth, ny * stageHeight]
  }

  // ---- Pointer handlers (drawing) ----

  const handlePointerDown = useCallback((e: KonvaEventObject<PointerEvent>) => {
    if (!isAnnotationMode) return
    const stage = e.target.getStage()
    if (!stage) return
    const pos = stage.getPointerPosition()
    if (!pos) return
    const [nx, ny] = norm(pos.x, pos.y)

    if (activeTool === 'text') {
      // Show text input overlay at click position
      setTextInput({ x: pos.x, y: pos.y, normX: nx, normY: ny })
      setTimeout(() => textInputRef.current?.focus(), 0)
      return
    }

    if (activeTool === 'angle') {
      anglePointsRef.current.push([nx, ny])
      angleClickCountRef.current += 1

      if (angleClickCountRef.current === 3) {
        // Finalize angle shape
        const [vertex, arm1, arm2] = anglePointsRef.current as [[number, number], [number, number], [number, number]]
        const angleDeg = computeAngleDeg(vertex, arm1, arm2)
        const newShape: AngleShape = {
          type: 'angle',
          id: crypto.randomUUID(),
          vertex,
          arm1,
          arm2,
          angleDeg,
          color: activeColor,
        }
        const newShapes = [...shapes, newShape]
        pushHistory(newShapes)
        angleClickCountRef.current = 0
        anglePointsRef.current = []
      }
      return
    }

    isDrawingRef.current = true
    const id = crypto.randomUUID()

    if (activeTool === 'freehand') {
      inProgressShapeRef.current = {
        type: 'freehand',
        id,
        points: [nx, ny],
        color: activeColor,
        strokeWidth: DEFAULT_STROKE_WIDTH,
      } as FreehandShape
    } else if (activeTool === 'line') {
      inProgressShapeRef.current = {
        type: 'line',
        id,
        points: [nx, ny, nx, ny],
        color: activeColor,
        strokeWidth: DEFAULT_STROKE_WIDTH,
      } as LineShape
    } else if (activeTool === 'arrow') {
      inProgressShapeRef.current = {
        type: 'arrow',
        id,
        points: [nx, ny, nx, ny],
        color: activeColor,
        strokeWidth: DEFAULT_STROKE_WIDTH,
      } as ArrowShape
    }
  }, [isAnnotationMode, activeTool, activeColor, shapes]) // eslint-disable-line react-hooks/exhaustive-deps

  const [inProgressShape, setInProgressShape] = useState<AnnotationShape | null>(null)

  const handlePointerMove = useCallback((e: KonvaEventObject<PointerEvent>) => {
    if (!isDrawingRef.current || !inProgressShapeRef.current) return
    const stage = e.target.getStage()
    if (!stage) return
    const pos = stage.getPointerPosition()
    if (!pos) return
    const [nx, ny] = norm(pos.x, pos.y)

    const current = inProgressShapeRef.current
    if (current.type === 'freehand') {
      const updated: FreehandShape = { ...current, points: [...current.points, nx, ny] }
      inProgressShapeRef.current = updated
      setInProgressShape({ ...updated })
    } else if (current.type === 'line') {
      const updated: LineShape = { ...current, points: [current.points[0], current.points[1], nx, ny] }
      inProgressShapeRef.current = updated
      setInProgressShape({ ...updated })
    } else if (current.type === 'arrow') {
      const updated: ArrowShape = { ...current, points: [current.points[0], current.points[1], nx, ny] }
      inProgressShapeRef.current = updated
      setInProgressShape({ ...updated })
    }
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  const handlePointerUp = useCallback(() => {
    if (!isDrawingRef.current || !inProgressShapeRef.current) return
    isDrawingRef.current = false
    const finished = inProgressShapeRef.current
    inProgressShapeRef.current = null
    setInProgressShape(null)
    const newShapes = [...shapes, finished]
    pushHistory(newShapes)
  }, [shapes]) // eslint-disable-line react-hooks/exhaustive-deps

  // ---- Two-finger pinch/pan (iPad) ----
  const handleTouchMove = useCallback((e: KonvaEventObject<TouchEvent>) => {
    const stage = stageRef.current
    if (!stage) return
    const evt = e.evt
    if (evt.touches.length === 2) {
      evt.preventDefault()
      const [t1, t2] = [evt.touches[0], evt.touches[1]]
      const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY)
      if (lastDist.current !== null) {
        const scale = dist / lastDist.current
        const oldScale = stage.scaleX()
        const newScale = Math.max(0.5, Math.min(5, oldScale * scale))
        const pointer = {
          x: (t1.clientX + t2.clientX) / 2 - stage.x(),
          y: (t1.clientY + t2.clientY) / 2 - stage.y(),
        }
        stage.scale({ x: newScale, y: newScale })
        stage.position({
          x: -(pointer.x / oldScale) * newScale + (t1.clientX + t2.clientX) / 2,
          y: -(pointer.y / oldScale) * newScale + (t1.clientY + t2.clientY) / 2,
        })
        stage.batchDraw()
      }
      lastDist.current = dist
    }
  }, [])

  const handleTouchEnd = useCallback(() => {
    lastDist.current = null
  }, [])

  // ---- Shape rendering helpers ----

  function renderShape(shape: AnnotationShape, key: string) {
    switch (shape.type) {
      case 'freehand': {
        const pts = shape.points.map((v, i) => i % 2 === 0 ? v * stageWidth : v * stageHeight)
        return (
          <Line
            key={key}
            points={pts}
            stroke={shape.color}
            strokeWidth={shape.strokeWidth}
            tension={0.5}
            lineCap="round"
            lineJoin="round"
            listening={false}
          />
        )
      }
      case 'line': {
        const pts = shape.points.map((v, i) => i % 2 === 0 ? v * stageWidth : v * stageHeight)
        return (
          <Line
            key={key}
            points={pts}
            stroke={shape.color}
            strokeWidth={shape.strokeWidth}
            lineCap="round"
            listening={false}
          />
        )
      }
      case 'arrow': {
        const pts = shape.points.map((v, i) => i % 2 === 0 ? v * stageWidth : v * stageHeight)
        return (
          <Arrow
            key={key}
            points={pts}
            stroke={shape.color}
            fill={shape.color}
            strokeWidth={shape.strokeWidth}
            pointerLength={10}
            pointerWidth={10}
            lineCap="round"
            listening={false}
          />
        )
      }
      case 'angle': {
        const [vx, vy] = denorm(shape.vertex[0], shape.vertex[1])
        const [a1x, a1y] = denorm(shape.arm1[0], shape.arm1[1])
        const [a2x, a2y] = denorm(shape.arm2[0], shape.arm2[1])
        // Draw two arms as lines from vertex
        const angle1 = Math.atan2(a1y - vy, a1x - vx)
        const angle2 = Math.atan2(a2y - vy, a2x - vx)
        // Arc spans from angle1 to angle2 at radius 30px
        const arcRadius = 30
        return (
          <>
            <Line key={`${key}-arm1`} points={[vx, vy, a1x, a1y]} stroke={shape.color} strokeWidth={2} lineCap="round" listening={false} />
            <Line key={`${key}-arm2`} points={[vx, vy, a2x, a2y]} stroke={shape.color} strokeWidth={2} lineCap="round" listening={false} />
            <Arc
              key={`${key}-arc`}
              x={vx}
              y={vy}
              innerRadius={0}
              outerRadius={arcRadius}
              angle={Math.round(shape.angleDeg)}
              rotation={(Math.min(angle1, angle2) * 180) / Math.PI}
              fill={`${shape.color}33`}
              stroke={shape.color}
              strokeWidth={1}
              listening={false}
            />
            <Text
              key={`${key}-label`}
              x={vx + arcRadius + 4}
              y={vy - 10}
              text={`${shape.angleDeg}°`}
              fill={shape.color}
              fontSize={13}
              fontStyle="bold"
              listening={false}
            />
          </>
        )
      }
      case 'text': {
        const [px, py] = denorm(shape.position[0], shape.position[1])
        return (
          <Text
            key={key}
            x={px}
            y={py}
            text={shape.text}
            fill={shape.color}
            fontSize={shape.fontSize}
            listening={false}
          />
        )
      }
    }
  }

  function commitText(value: string) {
    if (!textInput) return
    setTextInput(null)
    if (!value.trim()) return
    const newShape: TextShape = {
      type: 'text',
      id: crypto.randomUUID(),
      position: [textInput.normX, textInput.normY],
      text: value.trim(),
      color: activeColor,
      fontSize: 18,
    }
    const newShapes = [...shapes, newShape]
    pushHistory(newShapes)
  }

  if (stageWidth === 0 || stageHeight === 0) return null

  return (
    <div
      style={{
        position: 'absolute',
        inset: 0,
        pointerEvents: isAnnotationMode ? 'auto' : 'none',
        cursor: isAnnotationMode
          ? activeTool === 'text' ? 'text' : 'crosshair'
          : 'default',
      }}
    >
      <Stage
        ref={stageRef}
        width={stageWidth}
        height={stageHeight}
        onPointerDown={isAnnotationMode ? handlePointerDown : undefined}
        onPointerMove={isAnnotationMode ? handlePointerMove : undefined}
        onPointerUp={isAnnotationMode ? handlePointerUp : undefined}
        onTouchMove={isAnnotationMode ? handleTouchMove : undefined}
        onTouchEnd={isAnnotationMode ? handleTouchEnd : undefined}
      >
        <Layer>
          {/* Committed shapes */}
          {shapes.map((shape) => renderShape(shape, shape.id))}
          {/* In-progress shape (while drawing) */}
          {inProgressShape && renderShape(inProgressShape, `${inProgressShape.id}-inprogress`)}
        </Layer>
      </Stage>

      {/* Text input overlay */}
      {textInput && (
        <input
          ref={textInputRef}
          type="text"
          placeholder="Type label…"
          onBlur={(e) => commitText(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === 'Enter') commitText((e.target as HTMLInputElement).value)
            if (e.key === 'Escape') setTextInput(null)
          }}
          style={{
            position: 'absolute',
            left: textInput.x,
            top: textInput.y,
            background: 'rgba(0,0,0,0.7)',
            color: activeColor,
            border: `1px solid ${activeColor}`,
            borderRadius: 4,
            padding: '2px 6px',
            fontSize: 16,
            outline: 'none',
            minWidth: 120,
            zIndex: 50,
          }}
        />
      )}
    </div>
  )
}
```

**Note on angle cursor guide:** While `angleClickCountRef.current > 0`, show a small dot on the canvas at the vertex/arm1 positions to guide the three-point click. This is a minor UX enhancement — implement with a simple in-progress angle preview in the `inProgressShape` slot using the accumulated `anglePointsRef.current` points, showing partial lines from vertex to current mouse position.

**Note on `renderShape` returning fragments:** Because `AngleShape` renders multiple Konva nodes, the renderShape function for `type: 'angle'` returns a React Fragment with multiple nodes. The Stage/Layer accepts this correctly when iterating shapes.
  </action>
  <verify>
    <automated>npm ls react-konva 2>&1 | head -3 && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - konva and react-konva are installed (npm ls react-konva shows a version)
    - src/components/review/AnnotationCanvas.tsx exports AnnotationCanvas
    - Component accepts: containerRef, isAnnotationMode, shapes, onShapesChange, activeTool, activeColor
    - Freehand, line, arrow tools work via pointer events (draw on pointerdown + move + up)
    - Angle tool uses three-click state machine via angleClickCountRef
    - Text tool shows input overlay on click, commits on blur/Enter
    - Undo/redo implemented with historyRef capped at 50 entries
    - Konva.hitOnDragEnabled = true set at module level
    - pointer-events: none when isAnnotationMode === false
    - ResizeObserver sizes Stage to containerRef
    - npx tsc --noEmit exits 0
  </done>
</task>

<task type="auto">
  <name>Task 2: AnnotationToolbar component</name>
  <files>src/components/review/AnnotationToolbar.tsx</files>
  <action>
Create `src/components/review/AnnotationToolbar.tsx`.

Per CONTEXT.md locked decisions:
- Floating toolbar appears ONLY in annotation mode (rendered by parent conditionally)
- Tools: freehand, line, arrow, angle, text, color picker, clear frame
- Color choices: red, green, yellow, white, blue, orange (first four are required by ANN-04)
- Exact positioning is at Claude's discretion (top-left of canvas, with slight offset from edge)

Use lucide-react for icons (already installed). Icon mapping:
- freehand: Pencil
- line: Minus
- arrow: MoveRight
- angle: Triangle (or Ruler — pick whichever looks better)
- text: Type
- clear: Trash2

```typescript
// src/components/review/AnnotationToolbar.tsx
'use client'

import { Pencil, Minus, MoveRight, Triangle, Type, Trash2 } from 'lucide-react'
import type { AnnotationToolType, AnnotationColor } from '@/types/annotation'

interface AnnotationToolbarProps {
  activeTool: AnnotationToolType
  activeColor: AnnotationColor
  onToolChange: (tool: AnnotationToolType) => void
  onColorChange: (color: AnnotationColor) => void
  onClearFrame: () => void
  // isSaving: show a subtle saving indicator
  isSaving: boolean
}

const TOOLS: { type: AnnotationToolType; label: string; Icon: React.ElementType }[] = [
  { type: 'freehand', label: 'Freehand', Icon: Pencil },
  { type: 'line', label: 'Line', Icon: Minus },
  { type: 'arrow', label: 'Arrow', Icon: MoveRight },
  { type: 'angle', label: 'Angle', Icon: Triangle },
  { type: 'text', label: 'Text', Icon: Type },
]

// Required colors per ANN-04: red, green, yellow, white. Plus optional blue and orange.
const COLORS: { value: AnnotationColor; hex: string; label: string }[] = [
  { value: 'red', hex: '#ef4444', label: 'Red' },
  { value: 'green', hex: '#22c55e', label: 'Green' },
  { value: 'yellow', hex: '#eab308', label: 'Yellow' },
  { value: 'white', hex: '#ffffff', label: 'White' },
  { value: 'blue', hex: '#3b82f6', label: 'Blue' },
  { value: 'orange', hex: '#f97316', label: 'Orange' },
]

export function AnnotationToolbar({
  activeTool,
  activeColor,
  onToolChange,
  onColorChange,
  onClearFrame,
  isSaving,
}: AnnotationToolbarProps) {
  return (
    <div
      className="absolute top-3 left-3 z-30 flex flex-col gap-1 bg-neutral-900/90 backdrop-blur-sm border border-neutral-700 rounded-xl p-2 shadow-xl"
      // Prevent toolbar clicks from propagating to the annotation canvas below
      onPointerDown={(e) => e.stopPropagation()}
    >
      {/* Tool buttons */}
      {TOOLS.map(({ type, label, Icon }) => (
        <button
          key={type}
          type="button"
          title={label}
          aria-label={label}
          onClick={() => onToolChange(type)}
          className={`w-9 h-9 flex items-center justify-center rounded-lg transition-colors ${
            activeTool === type
              ? 'bg-blue-600 text-white'
              : 'text-neutral-400 hover:bg-neutral-700 hover:text-neutral-200'
          }`}
        >
          <Icon size={18} />
        </button>
      ))}

      {/* Divider */}
      <div className="h-px bg-neutral-700 my-1" />

      {/* Color swatches */}
      {COLORS.map(({ value, hex, label }) => (
        <button
          key={value}
          type="button"
          title={label}
          aria-label={`Color: ${label}`}
          onClick={() => onColorChange(value)}
          className="w-9 h-9 flex items-center justify-center rounded-lg"
          style={{ padding: 6 }}
        >
          <span
            className={`block w-5 h-5 rounded-full transition-transform ${
              activeColor === value ? 'scale-125 ring-2 ring-white ring-offset-1 ring-offset-neutral-900' : ''
            }`}
            style={{ backgroundColor: hex }}
          />
        </button>
      ))}

      {/* Divider */}
      <div className="h-px bg-neutral-700 my-1" />

      {/* Clear frame */}
      <button
        type="button"
        title="Clear all annotations on this frame"
        aria-label="Clear frame"
        onClick={onClearFrame}
        className="w-9 h-9 flex items-center justify-center rounded-lg text-neutral-400 hover:bg-red-900/60 hover:text-red-300 transition-colors"
      >
        <Trash2 size={16} />
      </button>

      {/* Saving indicator */}
      {isSaving && (
        <div className="w-9 flex justify-center">
          <span className="text-xs text-neutral-500">...</span>
        </div>
      )}
    </div>
  )
}
```
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - src/components/review/AnnotationToolbar.tsx exports AnnotationToolbar
    - Props: activeTool, activeColor, onToolChange, onColorChange, onClearFrame, isSaving
    - Renders five tool buttons (freehand, line, arrow, angle, text) with lucide-react icons
    - Renders six color swatches (red, green, yellow, white, blue, orange) — first four satisfy ANN-04
    - Active tool button highlighted in blue; active color swatch scaled + ringed
    - Clear frame button (Trash2 icon) in separate section
    - Toolbar click events do NOT propagate to underlying canvas (onPointerDown stopPropagation)
    - npx tsc --noEmit exits 0
  </done>
</task>

</tasks>

<verification>
- npm ls react-konva shows react-konva@19.x installed
- src/components/review/AnnotationCanvas.tsx exports AnnotationCanvas
- AnnotationCanvas accepts: containerRef, isAnnotationMode, shapes, onShapesChange, activeTool, activeColor
- Konva.hitOnDragEnabled = true set at module level (top of file, before component)
- pointer-events style is 'none' when isAnnotationMode === false, 'auto' when true
- Undo/redo keyboard handlers attached on window (Cmd/Ctrl+Z / Cmd/Ctrl+Shift+Z) only when isAnnotationMode is true
- History capped at 50 entries
- ResizeObserver sizes Stage to containerRef
- src/components/review/AnnotationToolbar.tsx exports AnnotationToolbar
- Toolbar includes all required tools and minimum four colors (red, green, yellow, white)
- Toolbar onPointerDown stops propagation to canvas
- npx tsc --noEmit exits 0
</verification>

<success_criteria>
After Phase 3 Plan 03:
1. AnnotationCanvas renders a Konva Stage sized to containerRef with all five tools implemented
2. Freehand/line/arrow draw correctly via pointer events (normalized coordinates)
3. Angle tool completes after three clicks with angleDeg label rendered
4. Text tool shows input overlay on click and commits to a TextShape on blur/Enter
5. Undo (Cmd+Z) and redo (Cmd+Shift+Z) work; history capped at 50
6. Two-finger pinch/pan functional on iPad (Konva.hitOnDragEnabled = true)
7. pointer-events: none when isAnnotationMode === false
8. AnnotationToolbar shows all tools, six colors (minimum four per ANN-04), clear button
9. npx tsc --noEmit exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/03-annotation-workspace/03-03-SUMMARY.md`
</output>
