---
phase: 03-annotation-workspace
plan: 04
type: execute
wave: 4
depends_on: [03-01, 03-02, 03-03]
files_modified:
  - src/components/review/ReviewPageClient.tsx
  - src/components/review/VideoWithOverlay.tsx
  - src/components/review/AnalysisTimeline.tsx
autonomous: true
requirements: [VID-03, VID-04, ANN-01, ANN-02, ANN-03, ANN-04, ANN-05]

must_haves:
  truths:
    - "Clicking the paused video canvas freezes frame and enters annotation mode automatically (no separate Annotate button)"
    - "Escape key or click outside canvas exits annotation mode; video stays paused"
    - "Annotations for the current frame load and display automatically when scrubbing to any annotated frame"
    - "Frame-by-frame stepping works via left/right arrow keys (desktop) and swipe left/right when paused (iPad)"
    - "Speed controls (0.25x, 0.5x, 1x) are always visible in the player bar"
    - "Annotations replay in sync during video playback (within 100ms tolerance)"
    - "Annotation frame markers (blue dots) appear on AnalysisTimeline alongside AI flag markers"
    - "AI skeleton stays visible by default in annotation mode; coach can toggle it off"
    - "Shapes saved automatically after each completed shape (debounced) and on annotation mode exit"
    - "npx tsc --noEmit exits 0 and npm run build exits 0"
  artifacts:
    - path: "src/components/review/ReviewPageClient.tsx"
      provides: "Wires annotation state machine, useAnnotations hook, AnnotationCanvas, AnnotationToolbar, video controls"
      exports: ["ReviewPageClient"]
    - path: "src/components/review/VideoWithOverlay.tsx"
      provides: "Extended with: no native controls, onPause/onPlay callbacks, frame-step API, speed control bar"
      exports: ["VideoWithOverlay", "VideoWithOverlayHandle"]
    - path: "src/components/review/AnalysisTimeline.tsx"
      provides: "Extended with annotation frame markers (blue dots) alongside existing AI flag markers"
      exports: ["AnalysisTimeline"]
  key_links:
    - from: "src/components/review/ReviewPageClient.tsx"
      to: "src/hooks/useAnnotations.ts"
      via: "useAnnotations(videoId)"
      pattern: "useAnnotations"
    - from: "src/components/review/ReviewPageClient.tsx"
      to: "src/components/review/AnnotationCanvas (dynamic import)"
      via: "dynamic(() => import('./AnnotationCanvas'), { ssr: false })"
      pattern: "AnnotationCanvas"
    - from: "src/components/review/ReviewPageClient.tsx"
      to: "src/lib/annotation/geometry.ts"
      via: "findNearestAnnotatedFrame for annotation sync during playback"
      pattern: "findNearestAnnotatedFrame"
---

<objective>
Wire all Phase 3 components into the existing review workspace. This plan extends ReviewPageClient with the annotation state machine, integrates the useAnnotations hook, modifies VideoWithOverlay to support frame stepping and speed controls, and adds annotation frame markers to AnalysisTimeline.

Purpose: This is the integration plan. Plans 01-03 built the pieces independently. This plan assembles them into the complete working feature.
Output: Updated ReviewPageClient, VideoWithOverlay, AnalysisTimeline.
</objective>

<execution_context>
@/Users/abhishekhodavdekar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhishekhodavdekar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-annotation-workspace/03-CONTEXT.md
@.planning/phases/03-annotation-workspace/03-RESEARCH.md
@.planning/phases/03-annotation-workspace/03-03-SUMMARY.md

<interfaces>
<!-- From src/components/review/ReviewPageClient.tsx (existing — Phase 2) -->
<!-- Already has: usePoseAnalysis, VideoWithOverlay, MechanicsSidebar, AnalysisTimeline -->
<!-- State: showSkeleton, currentTimeSec, videoDurationSec, flagNavIndex -->
<!-- overlayRef → VideoWithOverlayHandle → videoElement -->

<!-- From src/components/review/VideoWithOverlay.tsx (existing — Phase 2) -->
<!-- Currently: HLS init, skeleton draw on timeupdate, forwardRef with videoElement handle -->
<!-- Modification needed: -->
<!--   1. Remove native controls attribute — add custom speed control bar below video -->
<!--   2. Expose onPause / onPlay callbacks to ReviewPageClient for annotation mode detection -->
<!--   3. Expose stepFrame(direction: 'prev'|'next') on the handle (called by ReviewPageClient on arrow key) -->
<!--   4. Expose setPlaybackRate(rate: number) on the handle -->
<!--   5. Add swipe gesture detection for iPad frame stepping on the container div -->

<!-- From src/hooks/useAnnotations.ts (Plan 02) -->
```typescript
export function useAnnotations(videoId: string): {
  annotationsMap: Map<number, AnnotationShape[]>
  annotatedTimestamps: number[]
  saveFrame: (frameTimestampMs: number, shapes: AnnotationShape[]) => Promise<void>
  isSaving: boolean
}
```

<!-- From src/components/review/AnnotationCanvas.tsx (Plan 03) -->
<!-- Must be loaded with: dynamic(() => import('./AnnotationCanvas'), { ssr: false }) -->
```typescript
export function AnnotationCanvas(props: {
  containerRef: React.RefObject<HTMLDivElement | null>
  isAnnotationMode: boolean
  shapes: AnnotationShape[]
  onShapesChange: (shapes: AnnotationShape[]) => void
  activeTool: AnnotationToolType
  activeColor: AnnotationColor
}): JSX.Element
```

<!-- From src/components/review/AnnotationToolbar.tsx (Plan 03) -->
```typescript
export function AnnotationToolbar(props: {
  activeTool: AnnotationToolType
  activeColor: AnnotationColor
  onToolChange: (tool: AnnotationToolType) => void
  onColorChange: (color: AnnotationColor) => void
  onClearFrame: () => void
  isSaving: boolean
}): JSX.Element
```

<!-- From src/lib/annotation/geometry.ts (Plan 01) -->
```typescript
export function findNearestAnnotatedFrame(map: Map<number, unknown>, timMs: number, toleranceMs: number): number | null
```

<!-- CONTEXT.md locked decisions (NON-NEGOTIABLE): -->
<!-- - Clicking video while paused → enter annotation mode automatically (no separate button) -->
<!-- - Escape or click outside canvas → exit annotation mode; video stays paused -->
<!-- - Scrubbing to annotated frame → shows annotations automatically on canvas -->
<!-- - AI skeleton stays visible by default in annotation mode (coach can toggle) -->
<!-- - Arrow keys step frame-by-frame when paused (desktop) -->
<!-- - Swipe left/right when paused steps frames (iPad only — not phones) -->
<!-- - Speed controls (0.25x, 0.5x, 1x) always visible in player bar -->
<!-- - During playback: annotations overlay in sync; video does NOT auto-pause at annotated frames -->
<!-- - Annotation markers on timeline: blue dots, same visual pattern as Phase 2 AI flag markers -->
<!-- - Save on exit annotation mode (Escape / click-away); also auto-save after each shape (via useAnnotations) -->

<!-- RESEARCH.md open question resolved: -->
<!-- FFmpeg transcode-video.ts does NOT set -r flag — source fps is passed through -->
<!-- Frame step: use requestVideoFrameCallback on first play to detect actual frame interval -->
<!-- Fall back to 1/30s (30fps) if requestVideoFrameCallback not available or not yet sampled -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend VideoWithOverlay with frame stepping, speed control, and annotation mode callbacks</name>
  <files>src/components/review/VideoWithOverlay.tsx</files>
  <action>
Read the current `src/components/review/VideoWithOverlay.tsx` before editing. Make the following targeted changes:

**Changes to VideoWithOverlayHandle interface:** Add new methods to the handle:

```typescript
export interface VideoWithOverlayHandle {
  videoElement: HTMLVideoElement | null
  stepFrame: (direction: 'prev' | 'next') => void
  setPlaybackRate: (rate: number) => void
}
```

**Changes to Props interface:** Add new callbacks:

```typescript
interface Props {
  hlsUrl: string
  frames: FrameAnalysis[]
  showSkeleton: boolean
  onTimeUpdate?: (currentTimeSec: number) => void
  // Called when video pauses (including via click — annotation mode entry signal)
  onPause?: () => void
  // Called when video starts playing (annotation mode exit signal)
  onPlay?: () => void
}
```

**Changes to the component body:**

1. Add a ref for detected frame duration: `const frameDurationRef = useRef<number>(1 / 30)` (default 30fps)

2. After HLS init, wire `requestVideoFrameCallback` on first play to detect actual frame duration:

```typescript
// Detect actual frame duration on first playback via requestVideoFrameCallback
useEffect(() => {
  const video = videoRef.current
  if (!video) return
  let prevTime: number | null = null
  let samples = 0
  let totalDuration = 0

  function rvfc(_now: DOMHighResTimeStamp, metadata: VideoFrameCallbackMetadata) {
    if (prevTime !== null) {
      const delta = metadata.mediaTime - prevTime
      if (delta > 0 && delta < 0.5) {
        totalDuration += delta
        samples++
        if (samples >= 5) {
          frameDurationRef.current = totalDuration / samples
          return // Stop after 5 samples
        }
      }
    }
    prevTime = metadata.mediaTime
    if (samples < 5 && 'requestVideoFrameCallback' in video) {
      ;(video as HTMLVideoElement & { requestVideoFrameCallback: (cb: VideoFrameRequestCallback) => number }).requestVideoFrameCallback(rvfc)
    }
  }

  function handleFirstPlay() {
    if ('requestVideoFrameCallback' in video) {
      ;(video as HTMLVideoElement & { requestVideoFrameCallback: (cb: VideoFrameRequestCallback) => number }).requestVideoFrameCallback(rvfc)
    }
    video.removeEventListener('play', handleFirstPlay)
  }

  video.addEventListener('play', handleFirstPlay)
  return () => video.removeEventListener('play', handleFirstPlay)
}, [])
```

3. Add `onPause` and `onPlay` event listeners alongside the existing `timeupdate` listener:

```typescript
// Add to the timeupdate useEffect (or create a separate effect for pause/play):
video.addEventListener('pause', () => onPause?.())
video.addEventListener('play', () => onPlay?.())
// Remember to return cleanup for these too
```

4. Expose `stepFrame` and `setPlaybackRate` on the handle via `useImperativeHandle`:

```typescript
useImperativeHandle(ref, () => ({
  videoElement: videoRef.current,
  stepFrame: (direction: 'prev' | 'next') => {
    const video = videoRef.current
    if (!video || !video.paused) return
    const step = frameDurationRef.current
    video.currentTime = Math.max(
      0,
      Math.min(video.duration, video.currentTime + (direction === 'next' ? step : -step))
    )
  },
  setPlaybackRate: (rate: number) => {
    const video = videoRef.current
    if (video) video.playbackRate = rate
  },
}))
```

5. Remove the `controls` attribute from the `<video>` element (we add custom controls below).

6. Add a custom video control bar below the video in the returned JSX. The control bar contains:
   - Play/Pause button (using video.paused state)
   - Speed buttons: 0.25x, 0.5x, 1x — always visible per CONTEXT.md locked decision
   - Frame step buttons: ← and → (for users who prefer buttons over keyboard)

```typescript
// Add state for paused and playbackRate to drive the custom control bar
const [isPaused, setIsPaused] = useState(true)
const [playbackRate, setPlaybackRateState] = useState(1.0)

// Wire isPaused from video events (alongside existing timeupdate)
// In the useEffect that sets up timeupdate, also:
// video.addEventListener('pause', () => setIsPaused(true))
// video.addEventListener('play', () => setIsPaused(false))
```

Return structure (updated):
```tsx
return (
  <div className="relative inline-block w-full">
    {/* Swipe gesture container for iPad frame stepping (not phones) */}
    <div
      ref={swipeContainerRef}
      className="relative"
      onPointerDown={handleSwipeStart}
      onPointerUp={handleSwipeEnd}
    >
      <video ref={videoRef} className="w-full block" playsInline />
      {/* Skeleton canvas — pointer-events: none so annotation canvas above receives events */}
      <canvas ref={canvasRef} className="absolute inset-0 w-full h-full pointer-events-none" />
    </div>

    {/* Custom video control bar — always visible */}
    <div className="flex items-center gap-2 bg-neutral-900 px-3 py-2 rounded-b">
      {/* Play/Pause */}
      <button
        type="button"
        aria-label={isPaused ? 'Play' : 'Pause'}
        onClick={() => {
          const v = videoRef.current
          if (!v) return
          isPaused ? v.play() : v.pause()
        }}
        className="text-neutral-200 hover:text-white"
      >
        {isPaused ? (
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg>
        ) : (
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
        )}
      </button>

      {/* Frame step buttons */}
      <button
        type="button"
        aria-label="Previous frame"
        onClick={() => ref && 'current' in ref && ref.current?.stepFrame('prev')}
        className="text-neutral-400 hover:text-white text-xs px-1"
        title="Previous frame (← arrow key)"
      >
        ‹
      </button>
      <button
        type="button"
        aria-label="Next frame"
        onClick={() => ref && 'current' in ref && ref.current?.stepFrame('next')}
        className="text-neutral-400 hover:text-white text-xs px-1"
        title="Next frame (→ arrow key)"
      >
        ›
      </button>

      {/* Spacer */}
      <div className="flex-1" />

      {/* Speed controls — always visible */}
      {[0.25, 0.5, 1.0].map((rate) => (
        <button
          key={rate}
          type="button"
          onClick={() => {
            const v = videoRef.current
            if (v) v.playbackRate = rate
            setPlaybackRateState(rate)
          }}
          className={`text-xs px-2 py-0.5 rounded transition-colors ${
            playbackRate === rate
              ? 'bg-blue-600 text-white'
              : 'text-neutral-400 hover:text-white'
          }`}
        >
          {rate}x
        </button>
      ))}
    </div>
  </div>
)
```

**Swipe gesture for iPad frame stepping** (add `swipeContainerRef` and handlers — iPad only, not phones):

```typescript
const swipeContainerRef = useRef<HTMLDivElement>(null)
const swipeStartXRef = useRef<number | null>(null)
const SWIPE_THRESHOLD = 30 // px

function handleSwipeStart(e: React.PointerEvent) {
  if (e.pointerType === 'touch' || e.pointerType === 'pen') {
    swipeStartXRef.current = e.clientX
  }
}

function handleSwipeEnd(e: React.PointerEvent) {
  if (swipeStartXRef.current === null) return
  const delta = e.clientX - swipeStartXRef.current
  swipeStartXRef.current = null
  const video = videoRef.current
  if (!video || !video.paused || Math.abs(delta) < SWIPE_THRESHOLD) return
  const step = frameDurationRef.current
  video.currentTime = Math.max(
    0,
    Math.min(video.duration, video.currentTime + (delta > 0 ? -step : step))
  )
  // Note: swipe right = go backwards (natural iOS scrub direction)
}
```

**Important implementation notes:**
- The `onPause` / `onPlay` callbacks are called from video event listeners. Do not call them from the custom button handlers — the video events fire reliably for all pause/play sources.
- The `useImperativeHandle` depends on `frameDurationRef` which is a ref, so the handle does not need to be recreated when frame duration changes.
- When removing `controls` from `<video>`, the video element will no longer show any native UI — the custom control bar above is the only control surface.
- Do NOT break the skeleton draw-on-timeupdate logic — it must remain working.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - VideoWithOverlayHandle now exposes videoElement, stepFrame(direction), setPlaybackRate(rate)
    - Props includes onPause?: () => void and onPlay?: () => void callbacks
    - Native controls attribute removed from video element
    - Custom control bar renders Play/Pause button, frame step buttons, and 0.25x / 0.5x / 1x speed buttons — always visible
    - requestVideoFrameCallback used on first play to detect actual frame duration; fallback to 1/30s
    - Swipe gesture handlers (handleSwipeStart, handleSwipeEnd) on the video container for iPad
    - Skeleton draw-on-timeupdate still works
    - npx tsc --noEmit exits 0
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend AnalysisTimeline with annotation frame markers</name>
  <files>src/components/review/AnalysisTimeline.tsx</files>
  <action>
Read the current `src/components/review/AnalysisTimeline.tsx` before editing.

Add `annotatedTimestamps: number[]` to the Props interface and render blue annotation markers using the same visual pattern as the existing AI flag markers (same height, width, shape — different color and z-index).

Per CONTEXT.md locked decision: "Annotated frames show a colored marker/dot on the timeline scrubber (same visual pattern as Phase 2 AI-flagged frame markers)"

Updated Props interface:
```typescript
interface Props {
  frames: FrameAnalysis[]
  videoDurationSec: number
  currentTimeSec: number
  onSeek: (timeSec: number) => void
  // Timestamps (ms) of frames with coach annotations — shown as blue markers
  annotatedTimestamps?: number[]
}
```

Add the annotation markers rendering block AFTER the flagged frame markers block and BEFORE the closing `</div>`. Blue markers should be at z-index 15 (between the contact frame z-10 and AI flags z-20) so they are visible without overriding important AI markers:

```tsx
{/* Annotation frame markers — blue dots, same visual pattern as AI flag markers */}
{(annotatedTimestamps ?? []).map((tsMs) => (
  <button
    key={`ann-${tsMs}`}
    type="button"
    className="absolute top-1 h-6 w-1.5 rounded-sm cursor-pointer transition-opacity hover:opacity-100 opacity-80 z-15 bg-blue-400"
    style={{
      left: `${(tsMs / 1000 / videoDurationSec) * 100}%`,
      transform: 'translateX(-50%)',
    }}
    title={`Annotated frame at ${(tsMs / 1000).toFixed(1)}s`}
    onClick={() => onSeek(tsMs / 1000)}
    aria-label={`Seek to annotated frame at ${(tsMs / 1000).toFixed(1)}s`}
  />
))}
```

Note: `z-15` is not a built-in Tailwind class — use `style={{ zIndex: 15 }}` inline instead of a Tailwind class:

```tsx
<button
  key={`ann-${tsMs}`}
  type="button"
  className="absolute top-1 h-6 w-1.5 rounded-sm cursor-pointer transition-opacity hover:opacity-100 opacity-80 bg-blue-400"
  style={{
    left: `${(tsMs / 1000 / videoDurationSec) * 100}%`,
    transform: 'translateX(-50%)',
    zIndex: 15,
  }}
  title={`Annotated frame at ${(tsMs / 1000).toFixed(1)}s`}
  onClick={() => onSeek(tsMs / 1000)}
  aria-label={`Seek to annotated frame at ${(tsMs / 1000).toFixed(1)}s`}
/>
```
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - AnalysisTimeline Props includes annotatedTimestamps?: number[]
    - Blue annotation markers rendered with same height/width/rounded-sm shape as AI flag markers
    - Annotation markers use zIndex 15 (inline style) — between contact frame (10) and AI flags (20)
    - Clicking an annotation marker seeks to that frame
    - Existing AI flag markers and contact frame marker unchanged
    - npx tsc --noEmit exits 0
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend ReviewPageClient to wire annotation state machine</name>
  <files>src/components/review/ReviewPageClient.tsx</files>
  <action>
Read the current `src/components/review/ReviewPageClient.tsx` before editing. This is the highest-complexity task — read the current file carefully and make targeted additions rather than replacing the entire file.

**New imports to add:**
```typescript
import dynamic from 'next/dynamic'
import { useAnnotations } from '@/hooks/useAnnotations'
import { AnnotationToolbar } from './AnnotationToolbar'
import { findNearestAnnotatedFrame } from '@/lib/annotation/geometry'
import type { AnnotationShape, AnnotationToolType, AnnotationColor } from '@/types/annotation'

// Dynamic import — Konva accesses window/document; must not render on server
const AnnotationCanvas = dynamic(() => import('./AnnotationCanvas').then(m => m.AnnotationCanvas), { ssr: false })
```

**New state to add inside ReviewPageClient:**

```typescript
// --- Annotation state ---
// Workspace mode: 'playback' (normal) | 'annotating' (canvas active, toolbar visible)
const [mode, setMode] = useState<'playback' | 'annotating'>('playback')
const [frozenTimestampMs, setFrozenTimestampMs] = useState<number | null>(null)
// Current frame's shapes (controlled by AnnotationCanvas)
const [currentShapes, setCurrentShapes] = useState<AnnotationShape[]>([])
const [activeTool, setActiveTool] = useState<AnnotationToolType>('freehand')
const [activeColor, setActiveColor] = useState<AnnotationColor>('red')

// Annotation data from Supabase
const { annotationsMap, annotatedTimestamps, saveFrame, isSaving } = useAnnotations(videoId)

// Ref for the video+canvas container — passed to AnnotationCanvas for Stage sizing
const videoContainerRef = useRef<HTMLDivElement>(null)
```

**Annotation mode state machine handlers to add:**

```typescript
// Called by VideoWithOverlay when video pauses — enter annotation mode
const handleVideoPause = useCallback(() => {
  const video = overlayRef.current?.videoElement
  if (!video) return
  const tsMs = Math.round(video.currentTime * 1000)
  setFrozenTimestampMs(tsMs)
  // Load existing shapes for this frame (if any)
  const existingShapes = annotationsMap.get(tsMs) ?? []
  // Find nearest annotated frame within 100ms tolerance
  const nearestTs = findNearestAnnotatedFrame(annotationsMap, tsMs, 100)
  const shapes = nearestTs !== null ? (annotationsMap.get(nearestTs) ?? []) : existingShapes
  setCurrentShapes(shapes)
  setMode('annotating')
}, [annotationsMap])

// Exit annotation mode: save current shapes, return to playback mode
const exitAnnotationMode = useCallback(async () => {
  if (frozenTimestampMs === null) {
    setMode('playback')
    return
  }
  setMode('playback')
  await saveFrame(frozenTimestampMs, currentShapes)
  setFrozenTimestampMs(null)
}, [frozenTimestampMs, currentShapes, saveFrame])

// Called by VideoWithOverlay when video plays — exit annotation mode
const handleVideoPlay = useCallback(() => {
  if (mode === 'annotating') {
    exitAnnotationMode()
  }
}, [mode, exitAnnotationMode])

// Escape key: exit annotation mode
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Escape' && mode === 'annotating') {
      exitAnnotationMode()
    }
    // Arrow key frame stepping (desktop)
    if (mode === 'playback' || mode === 'annotating') {
      if (e.key === 'ArrowRight') overlayRef.current?.stepFrame('next')
      if (e.key === 'ArrowLeft') overlayRef.current?.stepFrame('prev')
    }
  }
  window.addEventListener('keydown', handleKeyDown)
  return () => window.removeEventListener('keydown', handleKeyDown)
}, [mode, exitAnnotationMode])

// Click outside canvas: exit annotation mode
// Attach to the outer workspace container div
const handleWorkspaceClick = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
  if (mode !== 'annotating') return
  // If click target is not inside the videoContainerRef, exit annotation mode
  if (videoContainerRef.current && !videoContainerRef.current.contains(e.target as Node)) {
    exitAnnotationMode()
  }
}, [mode, exitAnnotationMode])

// When shapes change (from AnnotationCanvas), auto-save debounced
const autoSaveTimer = useRef<ReturnType<typeof setTimeout> | null>(null)
const handleShapesChange = useCallback((shapes: AnnotationShape[]) => {
  setCurrentShapes(shapes)
  // Auto-save debounced 500ms after last change — safest for iPad mid-session
  if (autoSaveTimer.current) clearTimeout(autoSaveTimer.current)
  if (frozenTimestampMs !== null) {
    autoSaveTimer.current = setTimeout(() => {
      saveFrame(frozenTimestampMs, shapes)
    }, 500)
  }
}, [frozenTimestampMs, saveFrame])

// Sync currentShapes when scrubbing to an annotated frame during playback
// Also update when annotationsMap changes (after saveFrame)
useEffect(() => {
  if (mode === 'annotating' && frozenTimestampMs !== null) {
    const nearestTs = findNearestAnnotatedFrame(annotationsMap, frozenTimestampMs, 100)
    if (nearestTs !== null) {
      setCurrentShapes(annotationsMap.get(nearestTs) ?? [])
    }
  }
}, [annotationsMap]) // eslint-disable-line react-hooks/exhaustive-deps

// Annotation shapes to show during playback (read-only sync)
// During playback, look up nearest annotated frame within 100ms tolerance
const playbackAnnotationShapes = useMemo(() => {
  if (mode === 'annotating') return currentShapes
  const tsMs = Math.round(currentTimeSec * 1000)
  const nearestTs = findNearestAnnotatedFrame(annotationsMap, tsMs, 100)
  return nearestTs !== null ? (annotationsMap.get(nearestTs) ?? []) : []
}, [mode, currentShapes, currentTimeSec, annotationsMap])

// Clear all shapes on current frame
const handleClearFrame = useCallback(() => {
  setCurrentShapes([])
  if (frozenTimestampMs !== null) {
    saveFrame(frozenTimestampMs, [])
  }
}, [frozenTimestampMs, saveFrame])
```

**Updated JSX — changes to make in the return block:**

1. Add `onClick={handleWorkspaceClick}` to the outermost workspace div (the `flex flex-1 overflow-hidden` div).

2. Wrap the video area with `ref={videoContainerRef}` on the inner div that contains `VideoWithOverlay`. This is the div with `className="flex-1 flex items-center justify-center overflow-hidden"`.

3. Add `onPause={handleVideoPause}` and `onPlay={handleVideoPlay}` to `<VideoWithOverlay>`.

4. Add `AnnotationCanvas` inside the `videoContainerRef` div, absolutely positioned over the video, below the skeleton canvas:

```tsx
{/* Annotation canvas — stacked above skeleton canvas */}
<AnnotationCanvas
  containerRef={videoContainerRef}
  isAnnotationMode={mode === 'annotating'}
  shapes={mode === 'annotating' ? currentShapes : playbackAnnotationShapes}
  onShapesChange={handleShapesChange}
  activeTool={activeTool}
  activeColor={activeColor}
/>
```

5. Add `AnnotationToolbar` inside `videoContainerRef` div, shown only in annotation mode:

```tsx
{mode === 'annotating' && (
  <AnnotationToolbar
    activeTool={activeTool}
    activeColor={activeColor}
    onToolChange={setActiveTool}
    onColorChange={setActiveColor}
    onClearFrame={handleClearFrame}
    isSaving={isSaving}
  />
)}
```

6. Pass `annotatedTimestamps` to `AnalysisTimeline`:

```tsx
<AnalysisTimeline
  frames={frames}
  videoDurationSec={videoDurationSec}
  currentTimeSec={currentTimeSec}
  onSeek={handleSeek}
  annotatedTimestamps={annotatedTimestamps}
/>
```

**Container structure for video area (updated):**

The inner video area div needs to be `relative` and have `ref={videoContainerRef}` so AnnotationCanvas can size itself to it:

```tsx
<div
  ref={videoContainerRef}
  className="flex-1 flex items-center justify-center overflow-hidden relative"
>
  <VideoWithOverlay
    ref={overlayRef}
    hlsUrl={hlsUrl}
    frames={frames}
    showSkeleton={showSkeleton}
    onTimeUpdate={handleTimeUpdate}
    onPause={handleVideoPause}
    onPlay={handleVideoPlay}
  />
  <AnnotationCanvas
    containerRef={videoContainerRef}
    isAnnotationMode={mode === 'annotating'}
    shapes={mode === 'annotating' ? currentShapes : playbackAnnotationShapes}
    onShapesChange={handleShapesChange}
    activeTool={activeTool}
    activeColor={activeColor}
  />
  {mode === 'annotating' && (
    <AnnotationToolbar
      activeTool={activeTool}
      activeColor={activeColor}
      onToolChange={setActiveTool}
      onColorChange={setActiveColor}
      onClearFrame={handleClearFrame}
      isSaving={isSaving}
    />
  )}
</div>
```

**Cleanup:** On component unmount, clear autoSaveTimer:

```typescript
useEffect(() => {
  return () => {
    if (autoSaveTimer.current) clearTimeout(autoSaveTimer.current)
  }
}, [])
```
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20 && npm run build 2>&1 | tail -20</automated>
  </verify>
  <done>
    - ReviewPageClient imports useAnnotations, AnnotationCanvas (dynamic), AnnotationToolbar, findNearestAnnotatedFrame
    - mode state: 'playback' | 'annotating' — transitions correctly on pause/play/Escape/click-outside
    - handleVideoPause enters annotation mode and loads existing shapes for the frozen timestamp
    - handleVideoPlay and Escape both call exitAnnotationMode which saves shapes and resets to 'playback'
    - handleShapesChange updates currentShapes and triggers debounced auto-save (500ms)
    - Arrow key frame stepping wired (ArrowLeft/ArrowRight → overlayRef.current.stepFrame)
    - playbackAnnotationShapes syncs current shapes to canvas during playback using findNearestAnnotatedFrame with 100ms tolerance
    - videoContainerRef passed to AnnotationCanvas containerRef for Stage sizing
    - AnnotationToolbar visible only when mode === 'annotating'
    - AnalysisTimeline receives annotatedTimestamps from useAnnotations
    - npm run build exits 0
  </done>
</task>

</tasks>

<verification>
- VideoWithOverlay: native controls removed; custom bar has play/pause + frame step + 0.25x/0.5x/1x speed buttons
- VideoWithOverlay: handle exposes stepFrame(direction) and setPlaybackRate(rate)
- VideoWithOverlay: onPause and onPlay callbacks fire from video element events (not from button handlers)
- VideoWithOverlay: requestVideoFrameCallback used on first play to calibrate frame step size
- VideoWithOverlay: swipe gesture (pointerdown/pointerup delta) on video container steps frames on iPad
- AnalysisTimeline: annotatedTimestamps prop renders blue markers at correct timeline positions
- ReviewPageClient: mode toggles correctly (pause → annotating, play/Escape/click-outside → playback)
- ReviewPageClient: scrubbing to annotated frame loads shapes automatically
- ReviewPageClient: shapes auto-save debounced 500ms after each change and on exit
- ReviewPageClient: Arrow keys step frames via overlayRef.current.stepFrame
- ReviewPageClient: AnnotationCanvas receives containerRef for Stage sizing
- npm run build exits 0 with no type errors
</verification>

<success_criteria>
After Phase 3 Plan 04:
1. Clicking the paused video enters annotation mode — toolbar appears, canvas activates
2. Escape exits annotation mode and saves shapes
3. Speed controls (0.25x, 0.5x, 1x) always visible in player bar
4. Arrow keys (desktop) and swipe (iPad) step frame-by-frame when paused
5. Annotations replay in sync during playback (100ms tolerance)
6. Blue annotation markers visible on AnalysisTimeline
7. AI skeleton stays visible in annotation mode (toggle still works)
8. Shapes auto-save after each completed shape (debounced 500ms)
9. npm run build exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/03-annotation-workspace/03-04-SUMMARY.md`
</output>
