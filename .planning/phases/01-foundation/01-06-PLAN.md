---
phase: 01-foundation
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/actions/auth.ts
  - src/app/auth/callback/route.ts
  - src/app/invite/accept/page.tsx
autonomous: true
gap_closure: true
requirements:
  - AUTH-02
  - AUTH-03

must_haves:
  truths:
    - "Athlete clicks the invite email link, lands on /invite/accept, and is redirected to /submissions"
    - "coach_athletes row is updated from status=pending to status=active after athlete accepts"
    - "No redirect to /login occurs during invite acceptance when the invite link is valid"
  artifacts:
    - path: "src/actions/auth.ts"
      provides: "inviteAthlete with redirectTo pointing to /auth/callback?next=/invite/accept"
    - path: "src/app/auth/callback/route.ts"
      provides: "Detects ?next= param and routes there instead of doing role-based redirect"
    - path: "src/app/invite/accept/page.tsx"
      provides: "Reads already-established session, updates coach_athletes, redirects to /submissions"
  key_links:
    - from: "src/actions/auth.ts inviteAthlete"
      to: "src/app/auth/callback/route.ts"
      via: "redirectTo with ?next=/invite/accept query param"
      pattern: "next=/invite/accept"
    - from: "src/app/auth/callback/route.ts"
      to: "src/app/invite/accept/page.tsx"
      via: "NextResponse.redirect after exchangeCodeForSession"
      pattern: "redirect.*next"
    - from: "src/app/invite/accept/page.tsx"
      to: "coach_athletes table"
      via: "supabase.from('coach_athletes').update"
      pattern: "coach_athletes.*update"
---

<objective>
Fix the athlete invite acceptance flow so clicking the invite email link reliably lands the athlete on /submissions.

Purpose: The current flow is broken at three layers — wrong redirectTo in inviteAthlete, /auth/callback ignores ?next= routing, and the old /invite/[token] page reads hash-fragment tokens that PKCE flow never provides. This gap closure stitches the three pieces into a coherent PKCE-compatible invite flow.

Output:
- src/actions/auth.ts — redirectTo updated to /auth/callback?next=/invite/accept
- src/app/auth/callback/route.ts — detects ?next= param and routes there after code exchange
- src/app/invite/accept/page.tsx — new page that activates the athlete and redirects to /submissions
</objective>

<execution_context>
@/Users/abhishekhodavdekar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhishekhodavdekar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

<interfaces>
<!-- Current auth.ts inviteAthlete — lines 59-80 -->
<!-- Bug: redirectTo points to /auth/callback with no ?next= param -->
```typescript
export async function inviteAthlete(email: string, coachId: string) {
  const admin = getAdminClient()
  const { data, error } = await admin.auth.admin.inviteUserByEmail(email, {
    data: { role: 'athlete', invited_by: coachId },
    redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/auth/callback`,  // <-- WRONG: no ?next=
  })
  // ...
  await supabase.from('coach_athletes').insert({
    coach_id: coachId,
    athlete_email: email,
    status: 'pending',
  })
  return { success: true, userId: data.user?.id }
}
```

<!-- Current auth/callback/route.ts -->
<!-- Bug: reads ?next= but ignores it; always does role-based redirect; falls back to /login on error -->
```typescript
export async function GET(request: NextRequest) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/'  // <-- read but NEVER used

  if (code) {
    const supabase = await createClient()
    const { data, error } = await supabase.auth.exchangeCodeForSession(code)
    if (!error && data.user) {
      const role = data.user.user_metadata?.role ?? 'coach'
      const destination = role === 'athlete' ? '/submissions' : '/dashboard'
      return NextResponse.redirect(new URL(destination, origin))  // <-- ignores ?next=
    }
  }
  return NextResponse.redirect(new URL('/login?error=auth_callback_failed', origin))
}
```

<!-- Current /invite/[token]/page.tsx -->
<!-- Bug: reads window.location.hash (implicit flow) — PKCE delivers ?code=, not hash tokens -->
<!-- The [token] segment is never populated from a PKCE redirect URL -->
<!-- This file can be left in place (dead route) or deleted; it is no longer in the flow -->

<!-- Middleware PUBLIC_PATHS — /invite already included, so /invite/accept is also public -->
const PUBLIC_PATHS = ['/login', '/signup', '/auth/callback', '/invite']
// startsWith('/invite') covers /invite/accept — no middleware change needed
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix inviteAthlete redirectTo and update /auth/callback to honor ?next= param</name>
  <files>src/actions/auth.ts, src/app/auth/callback/route.ts</files>
  <action>
In src/actions/auth.ts, update the inviteAthlete function:
- Change redirectTo from `${APP_URL}/auth/callback` to `${APP_URL}/auth/callback?next=/invite/accept`
- No other changes to this file — signUp, signIn, signOut remain identical

In src/app/auth/callback/route.ts, update the GET handler:
- The `next` variable is already extracted from searchParams — it just needs to be USED
- After successful exchangeCodeForSession, if `next` is a valid internal path (starts with '/'), redirect to `new URL(next, origin)` instead of computing a role-based destination
- If `next` is absent or '/', keep the existing role-based redirect (athlete → /submissions, coach → /dashboard) so normal login flows still work
- Keep the same error fallback: redirect to /login?error=auth_callback_failed

Logic in callback route:
```typescript
if (!error && data.user) {
  if (next && next !== '/' && next.startsWith('/')) {
    // Explicit next param — used by invite flow
    return NextResponse.redirect(new URL(next, origin))
  }
  // Default: role-based redirect for normal login
  const role = data.user.user_metadata?.role ?? 'coach'
  const destination = role === 'athlete' ? '/submissions' : '/dashboard'
  return NextResponse.redirect(new URL(destination, origin))
}
```
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>
    - src/actions/auth.ts: inviteAthlete redirectTo contains "?next=/invite/accept"
    - src/app/auth/callback/route.ts: uses the `next` param to redirect when present and valid
    - TypeScript compiles clean (npx tsc --noEmit exits 0)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /invite/accept page that activates athlete and redirects to /submissions</name>
  <files>src/app/invite/accept/page.tsx</files>
  <action>
Create src/app/invite/accept/page.tsx as a 'use client' component.

By the time the athlete lands here, /auth/callback has already called exchangeCodeForSession — the PKCE code exchange is complete and the athlete has an active Supabase session in their cookies. This page does NOT need to parse any tokens from the URL.

The page should:
1. On mount (useEffect), call `supabase.auth.getUser()` to retrieve the authenticated user
2. If user is found, call `supabase.from('coach_athletes').update({ athlete_id: user.id, status: 'active', joined_at: new Date().toISOString() }).eq('athlete_email', user.email).eq('status', 'pending')`
3. After the update, call `router.replace('/submissions')` (replace, not push — athlete should not be able to back-navigate to this acceptance page)
4. If getUser() returns no user (edge case: session expired), redirect to /login
5. Visual states: loading spinner while processing, brief success message before redirect, error state if something fails

Note on coach_athletes update: the RLS policy "coach_athletes_update_coach" allows update WHERE coach_id = auth.uid(). The athlete is NOT the coach — this update will fail with RLS. Use the approach: call a server action to do this update (which runs server-side as the authed user with elevated context), OR note that the existing inviteAthlete already stores athlete_email and the callback should use a service-role update.

CORRECT APPROACH: Create a server action `acceptInvite()` in src/actions/auth.ts that uses the admin client to update coach_athletes. The /invite/accept page calls this server action after confirming the user session. The admin client bypasses RLS.

Add to src/actions/auth.ts:
```typescript
export async function acceptInvite() {
  const supabase = await createClient()
  const { data: { user }, error } = await supabase.auth.getUser()
  if (error || !user) throw new Error('Not authenticated')

  const admin = getAdminClient()
  const { error: updateError } = await admin
    .from('coach_athletes')
    .update({
      athlete_id: user.id,
      status: 'active',
      joined_at: new Date().toISOString(),
    })
    .eq('athlete_email', user.email)
    .eq('status', 'pending')

  if (updateError) throw updateError
  return { success: true }
}
```

The /invite/accept/page.tsx calls `acceptInvite()` server action on mount, then calls `router.replace('/submissions')`.

Use the same three visual states as the original invite page: loading spinner, success message, error message.

The middleware PUBLIC_PATHS already includes '/invite' (startsWith match), so /invite/accept is already public — no middleware change needed.
  </action>
  <verify>npx tsc --noEmit && ls /Users/abhishekhodavdekar/git/softball-mechanics/src/app/invite/accept/page.tsx</verify>
  <done>
    - src/app/invite/accept/page.tsx exists as a 'use client' component
    - src/actions/auth.ts exports acceptInvite() server action using admin client
    - Page calls acceptInvite() on mount and redirects to /submissions on success
    - TypeScript compiles clean (npx tsc --noEmit exits 0)
    - npm run build exits 0
  </done>
</task>

</tasks>

<verification>
Full invite flow verification (manual, since invite emails require a real Supabase instance):
1. npx tsc --noEmit exits 0
2. npm run build exits 0 (all routes generated cleanly)
3. Grep checks:
   - src/actions/auth.ts contains "next=/invite/accept" in the redirectTo string
   - src/actions/auth.ts exports acceptInvite function
   - src/app/auth/callback/route.ts uses the `next` variable in a conditional redirect
   - src/app/invite/accept/page.tsx exists and imports acceptInvite
</verification>

<success_criteria>
- inviteAthlete redirectTo in src/actions/auth.ts ends with ?next=/invite/accept
- /auth/callback routes to ?next= value when present (not role-based)
- /invite/accept page exists, calls acceptInvite server action, redirects to /submissions
- acceptInvite uses admin client to bypass RLS on coach_athletes update
- TypeScript compiles clean, npm run build exits 0
- UAT test 6 can now be re-run: athlete clicks invite link, lands on /invite/accept, gets redirected to /submissions
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-06-SUMMARY.md` following the summary template.
</output>
