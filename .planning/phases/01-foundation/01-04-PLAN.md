---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on:
  - 01-02
files_modified:
  - src/app/api/upload/presign/route.ts
  - src/components/upload/VideoUploader.tsx
  - src/components/upload/UploadQueue.tsx
  - src/components/upload/TranscodingStatus.tsx
  - src/components/video/HLSPlayer.tsx
autonomous: true
requirements:
  - VID-01
  - VID-02

must_haves:
  truths:
    - "Coach or athlete can select multiple video files (camera roll on mobile, drag-and-drop or file picker on desktop)"
    - "Selected files are uploaded directly to R2 via presigned PUT URL — not through the Next.js server"
    - "After upload, an Inngest video/uploaded event is fired to trigger transcoding"
    - "A per-file progress indicator stays on the same page during the ~2 minute transcoding wait"
    - "Once transcoding is complete, an HLS player renders the video in the browser"
  artifacts:
    - path: "src/app/api/upload/presign/route.ts"
      provides: "POST endpoint that returns presigned R2 PUT URL for a given file"
      exports: ["POST"]
      contains: "getPresignedPutUrl"
    - path: "src/components/upload/VideoUploader.tsx"
      provides: "Upload UI: react-dropzone for desktop, mobile <input> for camera roll"
      contains: "react-dropzone"
    - path: "src/components/upload/UploadQueue.tsx"
      provides: "Multi-file queue with per-file upload progress bars"
      contains: "progress"
    - path: "src/components/upload/TranscodingStatus.tsx"
      provides: "Polls video status and displays Processing/Ready badge"
      contains: "useQuery"
    - path: "src/components/video/HLSPlayer.tsx"
      provides: "hls.js wrapper for HLS video playback"
      contains: "Hls.isSupported()"
  key_links:
    - from: "src/components/upload/VideoUploader.tsx"
      to: "src/app/api/upload/presign/route.ts"
      via: "fetch POST /api/upload/presign with filename, contentType, videoId"
      pattern: "fetch.*presign|/api/upload/presign"
    - from: "src/components/upload/VideoUploader.tsx"
      to: "R2 presigned URL"
      via: "fetch PUT to presigned URL with file body"
      pattern: "method.*PUT|PUT.*presigned"
    - from: "src/components/upload/VideoUploader.tsx"
      to: "Inngest (via API route)"
      via: "POST /api/inngest-trigger after R2 upload completes"
      pattern: "video/uploaded|inngest"
    - from: "src/components/upload/TranscodingStatus.tsx"
      to: "Supabase videos table"
      via: "TanStack Query polling every 5s on video.status field"
      pattern: "refetchInterval|polling"
    - from: "src/components/video/HLSPlayer.tsx"
      to: "R2 public HLS URL"
      via: "hls.js loadSource(src) where src = video.hls_url"
      pattern: "hls.loadSource|Hls.isSupported"
---

<objective>
Build the video upload pipeline UI and HLS player component. Coach or athlete selects video files (multiple at once), they upload directly to R2 via presigned URLs, an Inngest event fires to start transcoding, and a polling indicator shows progress until the video is ready to play via HLS.

Purpose: This is the entry point for all content in the app. Nothing else works without video ingestion. Parallel with Plan 03 (auth pages) since they touch different files.
Output: Presign route, VideoUploader component, multi-file UploadQueue with progress, TranscodingStatus badge component, HLSPlayer component.
</objective>

<execution_context>
@/Users/abhishekhodavdekar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhishekhodavdekar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Presign route and HLS player component</name>
  <files>
    src/app/api/upload/presign/route.ts
    src/components/video/HLSPlayer.tsx
  </files>
  <action>
Create the presigned URL route handler and the HLS player component.

**src/app/api/upload/presign/route.ts** — returns a presigned R2 PUT URL for a given video file.

The route must be authenticated (only logged-in users can request presign URLs). It generates a unique videoId, builds the R2 key, stores the initial video record in Supabase, then returns the presigned URL.

```typescript
import { NextResponse, type NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getPresignedPutUrl } from '@/lib/r2'
import { z } from 'zod'

const PresignSchema = z.object({
  filename: z.string().min(1).max(255),
  contentType: z.string().regex(/^video\//),  // Must be a video MIME type
  athleteId: z.string().uuid(),               // Which athlete this video is for
  coachId: z.string().uuid(),                 // The coach's user ID
})

export async function POST(request: NextRequest) {
  const supabase = await createClient()

  // Verify authentication
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const body = await request.json()
  const parseResult = PresignSchema.safeParse(body)
  if (!parseResult.success) {
    return NextResponse.json({ error: parseResult.error.flatten() }, { status: 400 })
  }

  const { filename, contentType, athleteId, coachId } = parseResult.data

  // Generate a unique video ID upfront (used as R2 key and DB record)
  const videoId = crypto.randomUUID()
  const ext = filename.split('.').pop() ?? 'mp4'
  const r2Key = `raw/${videoId}/original.${ext}`

  // Create initial video record in DB (status: 'processing')
  const { error: dbError } = await supabase.from('videos').insert({
    id: videoId,
    athlete_id: athleteId,
    uploaded_by: user.id,
    coach_id: coachId,
    title: filename.replace(/\.[^.]+$/, ''),  // Strip extension for default title
    raw_r2_key: r2Key,
    status: 'processing',
  })

  if (dbError) {
    return NextResponse.json({ error: dbError.message }, { status: 500 })
  }

  // Generate presigned URL — contentType must match exactly what browser sends
  const presignedUrl = await getPresignedPutUrl(r2Key, contentType)

  return NextResponse.json({ presignedUrl, videoId, r2Key })
}
```

**src/components/video/HLSPlayer.tsx** — hls.js wrapper component.
Must handle both Safari (native HLS) and Chrome/Firefox (hls.js):

```tsx
'use client'

import { useEffect, useRef } from 'react'
import Hls from 'hls.js'

interface HLSPlayerProps {
  src: string
  className?: string
  autoPlay?: boolean
  poster?: string
}

export function HLSPlayer({ src, className = '', autoPlay = false, poster }: HLSPlayerProps) {
  const videoRef = useRef<HTMLVideoElement>(null)

  useEffect(() => {
    const video = videoRef.current
    if (!video || !src) return

    if (Hls.isSupported()) {
      const hls = new Hls({
        enableWorker: true,
        lowLatencyMode: false,
      })
      hls.loadSource(src)
      hls.attachMedia(video)

      hls.on(Hls.Events.ERROR, (_, data) => {
        if (data.fatal) {
          console.error('HLS fatal error:', data)
        }
      })

      return () => {
        hls.destroy()
      }
    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
      // Safari: native HLS
      video.src = src
    }
  }, [src])

  return (
    <video
      ref={videoRef}
      controls
      playsInline
      autoPlay={autoPlay}
      poster={poster}
      className={`w-full rounded-lg bg-black ${className}`}
    />
  )
}
```
  </action>
  <verify>
    <automated>cd /Users/abhishekhodavdekar/git/softball-mechanics && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    `npx tsc --noEmit` exits 0. Presign route validates input with Zod, creates video DB record, and returns `{ presignedUrl, videoId, r2Key }`. HLSPlayer handles both `Hls.isSupported()` path and Safari native path. Component is exported as named export `HLSPlayer`.
  </done>
</task>

<task type="auto">
  <name>Task 2: VideoUploader, UploadQueue, and TranscodingStatus components</name>
  <files>
    src/components/upload/VideoUploader.tsx
    src/components/upload/UploadQueue.tsx
    src/components/upload/TranscodingStatus.tsx
    src/app/api/inngest-trigger/route.ts
  </files>
  <action>
Build the complete upload UI: the uploader component that handles both desktop (react-dropzone) and mobile (native file input), the queue component showing per-file progress bars, and the transcoding status badge component that polls Supabase until the video is ready.

Also create a thin Inngest trigger route that fires the `video/uploaded` event (the frontend calls this after R2 upload completes).

**src/app/api/inngest-trigger/route.ts** — thin route to send Inngest events from client-side code:
```typescript
import { NextResponse, type NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { inngest } from '@/inngest/client'

export async function POST(request: NextRequest) {
  const supabase = await createClient()
  const { data: { user }, error } = await supabase.auth.getUser()
  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { name, data } = await request.json()
  await inngest.send({ name, data })
  return NextResponse.json({ ok: true })
}
```

**src/components/upload/UploadQueue.tsx** — displays the multi-file queue with per-file progress:
```tsx
'use client'

interface QueueItem {
  id: string
  filename: string
  progress: number  // 0-100
  status: 'waiting' | 'uploading' | 'transcoding' | 'ready' | 'error'
  videoId?: string
  errorMessage?: string
}

interface UploadQueueProps {
  items: QueueItem[]
}

export function UploadQueue({ items }: UploadQueueProps) {
  if (items.length === 0) return null

  return (
    <div className="mt-4 space-y-3">
      {items.map((item) => (
        <div key={item.id} className="bg-white rounded-lg border border-gray-200 p-4">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm font-medium text-gray-900 truncate max-w-[200px]">
              {item.filename}
            </span>
            <StatusBadge status={item.status} />
          </div>
          {(item.status === 'uploading' || item.status === 'transcoding') && (
            <div className="w-full bg-gray-100 rounded-full h-1.5">
              <div
                className="bg-blue-600 h-1.5 rounded-full transition-all duration-300"
                style={{ width: `${item.status === 'transcoding' ? 100 : item.progress}%` }}
              />
            </div>
          )}
          {item.status === 'transcoding' && (
            <p className="text-xs text-gray-500 mt-1">Transcoding… this takes about 2 minutes</p>
          )}
          {item.status === 'error' && (
            <p className="text-xs text-red-500 mt-1">{item.errorMessage ?? 'Upload failed'}</p>
          )}
        </div>
      ))}
    </div>
  )
}

function StatusBadge({ status }: { status: QueueItem['status'] }) {
  const config = {
    waiting:     { label: 'Waiting',     className: 'bg-gray-100 text-gray-600' },
    uploading:   { label: 'Uploading',   className: 'bg-blue-100 text-blue-700' },
    transcoding: { label: 'Processing',  className: 'bg-yellow-100 text-yellow-700' },
    ready:       { label: 'Ready',       className: 'bg-green-100 text-green-700' },
    error:       { label: 'Error',       className: 'bg-red-100 text-red-700' },
  }[status]

  return (
    <span className={`text-xs font-medium px-2 py-0.5 rounded-full ${config.className}`}>
      {config.label}
    </span>
  )
}

export type { QueueItem }
```

**src/components/upload/TranscodingStatus.tsx** — polls a single video's status from Supabase:
```tsx
'use client'

import { useQuery } from '@tanstack/react-query'
import { createClient } from '@/lib/supabase/client'

interface TranscodingStatusProps {
  videoId: string
  onReady?: (hlsUrl: string, thumbnailUrl: string) => void
}

async function fetchVideoStatus(videoId: string) {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('videos')
    .select('status, hls_url, thumbnail_url')
    .eq('id', videoId)
    .single()
  if (error) throw error
  return data
}

export function TranscodingStatus({ videoId, onReady }: TranscodingStatusProps) {
  const { data } = useQuery({
    queryKey: ['video-status', videoId],
    queryFn: () => fetchVideoStatus(videoId),
    refetchInterval: (query) => {
      // Stop polling once ready or error
      const status = query.state.data?.status
      if (status === 'ready' || status === 'error') return false
      return 5000  // Poll every 5 seconds while processing
    },
    onSuccess: (data) => {
      if (data?.status === 'ready' && data.hls_url && data.thumbnail_url) {
        onReady?.(data.hls_url, data.thumbnail_url)
      }
    },
  })

  const status = data?.status ?? 'processing'

  const labels: Record<string, string> = {
    processing: 'Processing…',
    ready:      'Ready for Review',
    reviewed:   'Reviewed',
    delivered:  'Delivered',
    error:      'Transcoding Failed',
  }

  const colors: Record<string, string> = {
    processing: 'bg-yellow-100 text-yellow-800',
    ready:      'bg-green-100 text-green-800',
    reviewed:   'bg-blue-100 text-blue-800',
    delivered:  'bg-purple-100 text-purple-800',
    error:      'bg-red-100 text-red-800',
  }

  return (
    <span className={`text-xs font-medium px-2.5 py-1 rounded-full ${colors[status] ?? colors.processing}`}>
      {labels[status] ?? 'Processing…'}
    </span>
  )
}
```

**src/components/upload/VideoUploader.tsx** — main uploader component combining desktop react-dropzone and mobile native input.

Key decisions from CONTEXT.md and RESEARCH.md:
- Desktop: react-dropzone with drag-and-drop zone + click to browse
- Mobile: `<input type="file" accept="video/*">` WITHOUT `capture` attribute (athletes select from camera roll, not live record)
- Multi-file: up to 10 files queued at once
- No redirect during upload — progress stays on the same page (CONTEXT.md locked decision)
- Coach assigns athlete during upload flow (required by CONTEXT.md locked decision)

```tsx
'use client'

import { useCallback, useRef, useState } from 'react'
import { useDropzone } from 'react-dropzone'
import { UploadQueue, type QueueItem } from './UploadQueue'

interface VideoUploaderProps {
  athleteId: string   // Must be provided — coach assigns athlete before uploading
  coachId: string
  onUploadComplete?: (videoId: string) => void
}

export function VideoUploader({ athleteId, coachId, onUploadComplete }: VideoUploaderProps) {
  const [queue, setQueue] = useState<QueueItem[]>([])
  const mobileInputRef = useRef<HTMLInputElement>(null)

  const updateItem = useCallback((id: string, update: Partial<QueueItem>) => {
    setQueue(prev => prev.map(item => item.id === id ? { ...item, ...update } : item))
  }, [])

  async function uploadFile(file: File) {
    const itemId = crypto.randomUUID()

    setQueue(prev => [...prev, {
      id: itemId,
      filename: file.name,
      progress: 0,
      status: 'waiting',
    }])

    try {
      // 1. Request presigned URL from server
      updateItem(itemId, { status: 'uploading' })
      const presignRes = await fetch('/api/upload/presign', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filename: file.name,
          contentType: file.type,   // Pass exact MIME type — R2 validates signature against this
          athleteId,
          coachId,
        }),
      })

      if (!presignRes.ok) throw new Error('Failed to get upload URL')
      const { presignedUrl, videoId, r2Key } = await presignRes.json()
      updateItem(itemId, { videoId })

      // 2. Upload directly to R2 via XHR (for progress events — fetch doesn't expose upload progress)
      await new Promise<void>((resolve, reject) => {
        const xhr = new XMLHttpRequest()
        xhr.open('PUT', presignedUrl)
        xhr.setRequestHeader('Content-Type', file.type)  // Must match presigned URL's ContentType

        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            updateItem(itemId, { progress: Math.round((e.loaded / e.total) * 100) })
          }
        })

        xhr.addEventListener('load', () => {
          if (xhr.status === 200) resolve()
          else reject(new Error(`R2 upload failed: ${xhr.status}`))
        })
        xhr.addEventListener('error', reject)
        xhr.send(file)
      })

      // 3. Fire Inngest event to start transcoding
      updateItem(itemId, { status: 'transcoding', progress: 100 })
      await fetch('/api/inngest-trigger', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: 'video/uploaded',
          data: { videoId, key: r2Key },
        }),
      })

      // 4. Wait for transcoding via polling (handled by TranscodingStatus component on the parent page)
      // Uploader's job is done — parent page polls for status change
      onUploadComplete?.(videoId)

    } catch (err) {
      updateItem(itemId, {
        status: 'error',
        errorMessage: err instanceof Error ? err.message : 'Upload failed',
      })
    }
  }

  const onDrop = useCallback((acceptedFiles: File[]) => {
    acceptedFiles.slice(0, 10).forEach(uploadFile)  // Max 10 files
  }, [athleteId, coachId])  // eslint-disable-line react-hooks/exhaustive-deps

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    accept: { 'video/*': [] },
    maxFiles: 10,
    noClick: true,  // We handle click separately for desktop
    onDrop,
  })

  function handleMobileFiles(e: React.ChangeEvent<HTMLInputElement>) {
    const files = Array.from(e.target.files ?? [])
    files.slice(0, 10).forEach(uploadFile)
    // Reset input so the same file can be re-selected
    e.target.value = ''
  }

  return (
    <div>
      {/* Desktop: drag-and-drop zone */}
      <div
        {...getRootProps()}
        className={`
          hidden md:flex flex-col items-center justify-center
          border-2 border-dashed rounded-xl p-10 cursor-pointer transition-colors
          ${isDragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300 bg-gray-50 hover:border-gray-400'}
        `}
        onClick={() => {
          // Trigger the hidden file input on click
          const input = document.querySelector('[data-dropzone-input]') as HTMLInputElement
          input?.click()
        }}
      >
        <input {...getInputProps()} data-dropzone-input />
        <svg className="w-10 h-10 text-gray-400 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5}
            d="M15 10l4.553-2.069A1 1 0 0121 8.82V15.18a1 1 0 01-1.447.894L15 14M3 8a2 2 0 012-2h8a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2V8z"
          />
        </svg>
        <p className="text-sm font-medium text-gray-700">
          {isDragActive ? 'Drop videos here' : 'Drag videos here or click to browse'}
        </p>
        <p className="text-xs text-gray-500 mt-1">Up to 10 videos at once</p>
      </div>

      {/* Mobile: native file input (no capture — athletes select from camera roll) */}
      <div className="md:hidden">
        <input
          ref={mobileInputRef}
          type="file"
          accept="video/*"
          // NO capture attribute — we want camera roll selection, not forced live recording
          multiple
          onChange={handleMobileFiles}
          className="hidden"
        />
        <button
          onClick={() => mobileInputRef.current?.click()}
          className="w-full flex items-center justify-center gap-2 bg-blue-600 text-white rounded-xl py-4 text-sm font-medium active:bg-blue-700"
        >
          <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
          </svg>
          Select videos to upload
        </button>
      </div>

      <UploadQueue items={queue} />
    </div>
  )
}
```
  </action>
  <verify>
    <automated>cd /Users/abhishekhodavdekar/git/softball-mechanics && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    `npx tsc --noEmit` exits 0. `VideoUploader` uses `react-dropzone` for desktop and native `<input type="file" accept="video/*">` WITHOUT `capture` attribute for mobile. XHR is used for upload progress (not fetch). `TranscodingStatus` polls with `refetchInterval`. `UploadQueue` renders per-file status badges. Inngest trigger route is authenticated.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes clean
2. Mobile input has `accept="video/*"` but NO `capture` attribute
3. Desktop upload uses react-dropzone (not native input)
4. Upload uses XHR (not fetch) to get progress events
5. Content-Type in XHR `setRequestHeader` matches `file.type` (same value sent to presign route)
6. Inngest trigger route `/api/inngest-trigger` is authenticated (checks `getUser()`)
7. `TranscodingStatus` stops polling when status is `ready` or `error`
</verification>

<success_criteria>
- TypeScript compiles clean
- Desktop drag-and-drop and click-to-browse work
- Mobile shows a tap-to-select button that opens camera roll
- Multiple files can be queued simultaneously with individual progress bars
- Progress indicator stays on the same page (no redirect) — CONTEXT.md locked decision met
- Inngest event fires after R2 upload completes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md` with:
- Files created
- Upload flow walkthrough (presign → R2 PUT → Inngest trigger)
- Note on XHR vs fetch choice (progress events)
- Confirm `capture` attribute is NOT present on mobile input
- Any TypeScript issues and resolutions
</output>
