---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/middleware.ts
  - src/lib/r2.ts
  - src/inngest/client.ts
  - src/app/api/inngest/route.ts
  - src/inngest/functions/transcode-video.ts
  - src/lib/ffmpeg.ts
autonomous: true
requirements:
  - AUTH-02
  - VID-02

must_haves:
  truths:
    - "Supabase browser client and server client are importable from their respective paths"
    - "Next.js middleware gates all authenticated routes and refreshes session cookies on every request"
    - "R2 client is configured and can generate presigned URLs"
    - "Inngest serve handler is registered at /api/inngest and the transcodeVideo function is wired"
    - "The transcodeVideo Inngest function handles all 5 steps: download raw video, transcode to HLS 720p, upload HLS tree, extract thumbnail, update DB status"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client for Client Components"
      exports: ["createBrowserClient"]
    - path: "src/lib/supabase/server.ts"
      provides: "Server Supabase client for Server Components and Route Handlers"
      exports: ["createClient"]
    - path: "src/middleware.ts"
      provides: "Auth + role redirect middleware"
      contains: "supabase.auth.getUser()"
    - path: "src/lib/r2.ts"
      provides: "S3Client configured for Cloudflare R2"
      exports: ["r2", "getPresignedPutUrl", "getPresignedGetUrl"]
    - path: "src/inngest/client.ts"
      provides: "Inngest client instance"
      exports: ["inngest"]
    - path: "src/app/api/inngest/route.ts"
      provides: "Inngest serve handler (GET, POST, PUT)"
      contains: "transcodeVideo"
    - path: "src/inngest/functions/transcode-video.ts"
      provides: "5-step transcoding Inngest function"
      contains: "step.run"
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/supabase/server.ts"
      via: "createServerClient from @supabase/ssr"
      pattern: "createServerClient"
    - from: "src/app/api/inngest/route.ts"
      to: "src/inngest/functions/transcode-video.ts"
      via: "functions: [transcodeVideo] in serve()"
      pattern: "functions.*transcodeVideo"
    - from: "src/inngest/functions/transcode-video.ts"
      to: "src/lib/r2.ts"
      via: "R2 GetObject/PutObject for raw video download and HLS upload"
      pattern: "r2|GetObjectCommand|PutObjectCommand"

user_setup:
  - service: supabase
    why: "Authentication, database, row-level security"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard → Project Settings → API → Project URL"
      - name: NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY
        source: "Supabase Dashboard → Project Settings → API → Publishable key (starts with sb_publishable_)"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard → Project Settings → API → service_role key (keep secret)"
    dashboard_config:
      - task: "Run supabase/migrations/001_initial_schema.sql in SQL Editor or via `supabase db push`"
        location: "Supabase Dashboard → SQL Editor"
  - service: cloudflare-r2
    why: "Video storage (raw uploads and HLS output)"
    env_vars:
      - name: CF_ACCOUNT_ID
        source: "Cloudflare Dashboard → right sidebar → Account ID"
      - name: R2_ACCESS_KEY_ID
        source: "Cloudflare Dashboard → R2 → Manage API tokens → Create API token"
      - name: R2_SECRET_ACCESS_KEY
        source: "Same R2 API token creation page (shown once)"
      - name: R2_BUCKET_NAME
        source: "Name of the R2 bucket you create (e.g., softball-mechanics)"
      - name: R2_PUBLIC_URL
        source: "Cloudflare Dashboard → R2 → your bucket → Settings → Public access URL"
    dashboard_config:
      - task: "Create R2 bucket named softball-mechanics (or your chosen name)"
        location: "Cloudflare Dashboard → R2 → Create bucket"
      - task: "Enable public access on the bucket (for HLS segment delivery)"
        location: "Cloudflare Dashboard → R2 → bucket → Settings → Public access → Allow"
      - task: "Set CORS policy on the bucket to allow browser PUT uploads from your domain"
        location: "Cloudflare Dashboard → R2 → bucket → Settings → CORS policy"
        notes: |
          CORS JSON to paste:
          [{"AllowedOrigins":["http://localhost:3000","https://your-production-domain.com"],"AllowedMethods":["PUT","GET","HEAD"],"AllowedHeaders":["content-type"],"MaxAgeSeconds":3600}]
          CRITICAL: Use exact "content-type" in AllowedHeaders — R2 does NOT support wildcard AllowedHeaders
  - service: inngest
    why: "Durable background job runner for video transcoding (bypasses Vercel serverless timeout)"
    env_vars:
      - name: INNGEST_EVENT_KEY
        source: "Inngest Dashboard → your app → Event keys → Create key"
      - name: INNGEST_SIGNING_KEY
        source: "Inngest Dashboard → your app → Signing keys"
    dashboard_config:
      - task: "Create a new Inngest app named 'softball-mechanics'"
        location: "https://app.inngest.com → New app"
      - task: "After running dev server, sync functions at http://localhost:3000/api/inngest"
        location: "Inngest Dev Server (npx inngest-cli@latest dev -u http://localhost:3000/api/inngest)"
---

<objective>
Wire the three foundational services — Supabase (auth + DB), Cloudflare R2 (storage), and Inngest (background jobs) — into the Next.js project. This plan produces the infrastructure layer that auth pages, video upload, and roster features all depend on.

Purpose: These are load-bearing wires. Auth pages need Supabase clients. Video upload needs the R2 presigner. Transcoding needs the Inngest function. Getting the wiring exactly right here prevents subtle bugs in all later plans.
Output: Supabase browser + server clients, Next.js auth middleware, R2 S3 client with presign helpers, Inngest client + serve handler + complete transcodeVideo function.
</objective>

<execution_context>
@/Users/abhishekhodavdekar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhishekhodavdekar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Supabase clients and Next.js auth middleware</name>
  <files>
    src/lib/supabase/client.ts
    src/lib/supabase/server.ts
    src/middleware.ts
  </files>
  <action>
Create three files implementing the Supabase SSR pattern from 01-RESEARCH.md (Pattern 1 and the Supabase Middleware Setup code example).

**src/lib/supabase/client.ts** — browser client for Client Components:
```typescript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!
  )
}
```

**src/lib/supabase/server.ts** — server client for Server Components, Route Handlers, and Server Actions:
```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
    {
      cookies: {
        getAll() { return cookieStore.getAll() },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options))
          } catch {}
        },
      },
    }
  )
}
```

**src/middleware.ts** — refreshes session on every request, enforces auth gate, allows /invite routes through:
- Import `createServerClient` from `@supabase/ssr` (NOT from `src/lib/supabase/server.ts` — middleware has different cookie handling)
- Use `supabase.auth.getUser()` (NOT `getSession()` — insecure, doesn't verify JWT signature)
- Redirect unauthenticated users to `/login` EXCEPT for paths: `/login`, `/signup`, `/auth/callback`, `/invite`
- Attach the user's role from `user.user_metadata.role` to the response header `x-user-role` so server components can read it without another DB call

Full middleware implementation:
```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

const PUBLIC_PATHS = ['/login', '/signup', '/auth/callback', '/invite']

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
    {
      cookies: {
        getAll() { return request.cookies.getAll() },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            request.cookies.set(name, value)
            supabaseResponse.cookies.set(name, value, options)
          })
        },
      },
    }
  )

  const { data: { user } } = await supabase.auth.getUser()

  const isPublicPath = PUBLIC_PATHS.some(p =>
    request.nextUrl.pathname.startsWith(p)
  )

  if (!user && !isPublicPath) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // Attach role to header for server components
  if (user) {
    supabaseResponse.headers.set(
      'x-user-role',
      user.user_metadata?.role ?? 'coach'
    )
  }

  return supabaseResponse
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],
}
```
  </action>
  <verify>
    <automated>cd /Users/abhishekhodavdekar/git/softball-mechanics && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    `npx tsc --noEmit` exits 0 (no type errors). All three files exist. `src/middleware.ts` contains `supabase.auth.getUser()` (not `getSession`). Middleware matcher is present. `x-user-role` header is set.
  </done>
</task>

<task type="auto">
  <name>Task 2: R2 client and Inngest client + transcodeVideo function</name>
  <files>
    src/lib/r2.ts
    src/lib/ffmpeg.ts
    src/inngest/client.ts
    src/app/api/inngest/route.ts
    src/inngest/functions/transcode-video.ts
  </files>
  <action>
Create the R2 storage client, FFmpeg helper, Inngest client, serve handler, and the complete transcodeVideo function.

**src/lib/r2.ts** — S3Client configured for Cloudflare R2 with helper functions:
```typescript
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3'
import { getSignedUrl } from '@aws-sdk/s3-request-presigner'

export const r2 = new S3Client({
  region: 'auto',
  endpoint: `https://${process.env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com`,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
})

export async function getPresignedPutUrl(key: string, contentType: string): Promise<string> {
  // ContentType MUST match exactly what browser sends — R2 validates signature
  return getSignedUrl(
    r2,
    new PutObjectCommand({
      Bucket: process.env.R2_BUCKET_NAME!,
      Key: key,
      ContentType: contentType,
    }),
    { expiresIn: 3600 }
  )
}

export async function getPresignedGetUrl(key: string): Promise<string> {
  return getSignedUrl(
    r2,
    new GetObjectCommand({
      Bucket: process.env.R2_BUCKET_NAME!,
      Key: key,
    }),
    { expiresIn: 3600 }
  )
}

export function getPublicUrl(key: string): string {
  return `${process.env.R2_PUBLIC_URL}/${key}`
}
```

**src/lib/ffmpeg.ts** — FFmpeg spawn helper that runs a command and returns a promise:
```typescript
import { spawn } from 'child_process'
import ffmpegPath from 'ffmpeg-static'

export function runFfmpeg(args: string[]): Promise<void> {
  return new Promise((resolve, reject) => {
    if (!ffmpegPath) {
      reject(new Error('ffmpeg-static binary path is null — check deployment environment'))
      return
    }

    const proc = spawn(ffmpegPath, args)

    let stderr = ''
    proc.stderr.on('data', (data: Buffer) => { stderr += data.toString() })

    proc.on('close', (code) => {
      if (code === 0) {
        resolve()
      } else {
        reject(new Error(`FFmpeg exited with code ${code}. stderr: ${stderr.slice(-500)}`))
      }
    })

    proc.on('error', reject)
  })
}
```

**src/inngest/client.ts**:
```typescript
import { Inngest } from 'inngest'

export const inngest = new Inngest({ id: 'softball-mechanics' })
```

**src/app/api/inngest/route.ts** — serve handler (MUST export GET, POST, PUT per Inngest docs):
```typescript
import { serve } from 'inngest/next'
import { inngest } from '@/inngest/client'
import { transcodeVideo } from '@/inngest/functions/transcode-video'

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [transcodeVideo],
  // Add ALL new Inngest functions here — if missing, events fire but nothing runs
})
```

**src/inngest/functions/transcode-video.ts** — complete 5-step transcoding function.

The function handles: `video/uploaded` event → download raw video from R2 to /tmp → run FFmpeg to 720p HLS → upload HLS tree to R2 → extract thumbnail → update video row in DB.

```typescript
import { inngest } from '@/inngest/client'
import { r2, getPublicUrl } from '@/lib/r2'
import { runFfmpeg } from '@/lib/ffmpeg'
import { GetObjectCommand, PutObjectCommand, ListObjectsV2Command } from '@aws-sdk/client-s3'
import { createClient } from '@supabase/supabase-js'
import { writeFile, readFile, readdir, mkdir } from 'fs/promises'
import { existsSync } from 'fs'
import { join } from 'path'
import { Readable } from 'stream'

// Use service role client — bypasses RLS so function can update any video row
function getServiceClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}

async function streamToBuffer(stream: Readable): Promise<Buffer> {
  const chunks: Buffer[] = []
  for await (const chunk of stream) {
    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))
  }
  return Buffer.concat(chunks)
}

export const transcodeVideo = inngest.createFunction(
  { id: 'transcode-video', retries: 3 },
  { event: 'video/uploaded' },
  async ({ event, step }) => {
    const { videoId, key } = event.data as { videoId: string; key: string }

    // Step 1: Download raw video from R2 to /tmp
    const localInputPath = await step.run('download-raw-video', async () => {
      const result = await r2.send(new GetObjectCommand({
        Bucket: process.env.R2_BUCKET_NAME!,
        Key: key,
      }))

      const buffer = await streamToBuffer(result.Body as Readable)
      const ext = key.split('.').pop() ?? 'mp4'
      const localPath = `/tmp/${videoId}.${ext}`
      await writeFile(localPath, buffer)
      return localPath
    })

    // Step 2: Run FFmpeg → single 720p HLS
    const hlsOutputDir = `/tmp/${videoId}-hls`
    await step.run('transcode-to-hls', async () => {
      if (!existsSync(hlsOutputDir)) await mkdir(hlsOutputDir, { recursive: true })
      await runFfmpeg([
        '-i', localInputPath,
        '-vf', 'scale=1280:720',
        '-c:v', 'libx264',
        '-b:v', '2800k',
        '-c:a', 'aac',
        '-b:a', '128k',
        '-ar', '48000',
        '-ac', '2',
        '-hls_time', '6',
        '-hls_segment_filename', join(hlsOutputDir, 'segment_%03d.ts'),
        '-f', 'hls',
        join(hlsOutputDir, 'playlist.m3u8'),
      ])
    })

    // Step 3: Upload HLS tree to R2
    const hlsBaseKey = `videos/${videoId}/hls`
    await step.run('upload-hls-to-r2', async () => {
      const files = await readdir(hlsOutputDir)
      for (const filename of files) {
        const fileBuffer = await readFile(join(hlsOutputDir, filename))
        const contentType = filename.endsWith('.m3u8')
          ? 'application/vnd.apple.mpegurl'
          : 'video/mp2t'
        await r2.send(new PutObjectCommand({
          Bucket: process.env.R2_BUCKET_NAME!,
          Key: `${hlsBaseKey}/${filename}`,
          Body: fileBuffer,
          ContentType: contentType,
        }))
      }
    })

    // Step 4: Extract thumbnail (frame at 2 seconds)
    const thumbnailKey = `videos/${videoId}/thumbnail.jpg`
    await step.run('extract-thumbnail', async () => {
      const thumbnailPath = `/tmp/${videoId}-thumb.jpg`
      await runFfmpeg([
        '-i', localInputPath,
        '-ss', '00:00:02',
        '-vframes', '1',
        '-q:v', '2',
        thumbnailPath,
      ])
      const thumbBuffer = await readFile(thumbnailPath)
      await r2.send(new PutObjectCommand({
        Bucket: process.env.R2_BUCKET_NAME!,
        Key: thumbnailKey,
        Body: thumbBuffer,
        ContentType: 'image/jpeg',
      }))
    })

    // Step 5: Update video status in DB
    await step.run('update-status', async () => {
      const supabase = getServiceClient()
      const hlsUrl = getPublicUrl(`${hlsBaseKey}/playlist.m3u8`)
      const thumbnailUrl = getPublicUrl(thumbnailKey)

      const { error } = await supabase
        .from('videos')
        .update({
          status: 'ready',
          hls_url: hlsUrl,
          thumbnail_url: thumbnailUrl,
          transcoded_at: new Date().toISOString(),
        })
        .eq('id', videoId)

      if (error) throw new Error(`DB update failed: ${error.message}`)
    })

    return { videoId, status: 'ready' }
  }
)
```

Key implementation notes:
- `SUPABASE_SERVICE_ROLE_KEY` is used in Step 5 to bypass RLS — add this to `.env.local.example` as well
- Each `step.run()` is a checkpoint — if the function fails at Step 3, Inngest retries from Step 3 (not from Step 1)
- The ffmpeg-static binary path may be undefined in Vercel Lambda but will work in Inngest's worker environment — see RESEARCH.md Open Question #1 and Pitfall 4
- Add `SUPABASE_SERVICE_ROLE_KEY` to `.env.local.example` if it is not already there
  </action>
  <verify>
    <automated>cd /Users/abhishekhodavdekar/git/softball-mechanics && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    `npx tsc --noEmit` exits 0. All 5 files exist. `src/app/api/inngest/route.ts` exports GET, POST, PUT. `transcodeVideo` contains all 5 `step.run()` calls. `src/lib/r2.ts` exports `r2`, `getPresignedPutUrl`, `getPublicUrl`. `SUPABASE_SERVICE_ROLE_KEY` is in `.env.local.example`.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero type errors
2. `src/middleware.ts` uses `supabase.auth.getUser()` (grep confirms no `getSession` call)
3. All 5 Inngest function steps are present: download-raw-video, transcode-to-hls, upload-hls-to-r2, extract-thumbnail, update-status
4. R2 presigned PUT generates URL with explicit ContentType (not wildcard)
5. `src/app/api/inngest/route.ts` includes `transcodeVideo` in the functions array
</verification>

<success_criteria>
- TypeScript compiles clean
- Middleware correctly gates unauthenticated requests and allows public paths
- Inngest function is structured with 5 retry-safe step.run() checkpoints
- R2 client exports helper functions used by upload route and transcode function
- No business logic yet — only infrastructure wiring
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` with:
- Confirmation of each file created
- Any TypeScript issues encountered and how they were resolved
- Note whether `ffmpegPath` is non-null when logged locally (early validation of Pitfall 4)
- List of all env vars added to `.env.local.example`
</output>
